[
  {
    "objectID": "final_project.html",
    "href": "final_project.html",
    "title": "Development Opportunity Optimizer",
    "section": "",
    "text": "MUSA 5500 Geospatial Data Science in Pytho\nUniversity of Pennslyvania\nFinal Project\nAuthor: Joshua Rigsby\nInstructor: Dr.¬†Xiojiang Li"
  },
  {
    "objectID": "final_project.html#introduction",
    "href": "final_project.html#introduction",
    "title": "Development Opportunity Optimizer",
    "section": "Introduction",
    "text": "Introduction\nThis project is predicated by real estate and financial research to design and build an computational analytical tool that assists the development team during the feasability phase of real estate development.\nResearch Question\nWhich properties, (vacant and developed) in Philadelphia present the highest redevelopment potential determined by: market value uplift, market gap, land utilization, accesability, and zoning capacity?\nObjectives\nThe research question is studied and analyzied through the design and implementation of a geospatial data model that scores and ranks properties according to redevelopment potential. The result is the creation of a data-driven highest and best use development screening tool, that significantly aids development through the automation of market research, site selection, and value projection at a large scale, saving time and resources during idea inception, refinement and feasibility. Given that the data exists the model can be easily refitted to accomodate any city in the world.\nThe model will identify properties and parcels in Philadelphia, that are under-utilized, vacant, low value, and maintain old zoning, to then optimize a development scenario, via - proposing best use (residential, mixed-use, infill), - estimating value uplift - prioritizing optimization of opportunity.\nThe output is both a data-science and business development tool usable by a developement and investment teams."
  },
  {
    "objectID": "final_project.html#methodology",
    "href": "final_project.html#methodology",
    "title": "Development Opportunity Optimizer",
    "section": "Methodology",
    "text": "Methodology\nData Identification\nData on building ansd zoning permits, real estate transfers, street networks via OSMnx, Philadelphia property assesments, vacant property indicators, zoning overlays, census data, and several gegraphic boundries has been pre selected to run the model\nData Reading and combining:\nThe data will be read into GeoPandas DataFrames with a common CRS and matching parcel identifiers.\nSpatial Joining\nData will be aggregated and joined to parcel data serving as the initial link between geographic data and numerical data.\nFinancial and Land Computations\nCalculations for build ratio proxy to represent underutilization, market gap calculations, flags for old structures, accessibility score calculations, zoning capacity calculations, potential uplift value calculations.\nFinancial Optimization\nEstimation of potential project value for each parcel using zoning capacity and industry standard pro-forma assumptions.\nRedevelopment Opportunity Score: Financial + Spatial\nAll calculations culminate with the computaion for an opportunity Score, using a weighted composite of metrics, using weighted metrics that and assign weights reflecting business priorities.\nVisual Dashboard\n\nDisplays properties colored by opportunity score\nSlider to adjust budget and re-run optimization\nTable of top 10 parcels\nHover to show key financial computations"
  },
  {
    "objectID": "final_project.html#data-onboarding-data-preparation-and-feature-engineering",
    "href": "final_project.html#data-onboarding-data-preparation-and-feature-engineering",
    "title": "Development Opportunity Optimizer",
    "section": "1. Data onboarding, Data Preparation and Feature Engineering",
    "text": "1. Data onboarding, Data Preparation and Feature Engineering\nMaybe add subtitle still need to do feature engineering maybe that can be a seperate section\n\n1.1 Python Package Imports\n\n\nimport pandas as pd\nimport geopandas as gpd\nimport numpy as np\nimport osmnx as ox\nimport networkx as nx\nimport hvplot.pandas \nimport holoviews as hv\nimport folium\nimport datashader as ds\nimport xyzservices\nimport seaborn as sns\nimport pulp\nimport altair as alt\nalt.data_transformers.enable(\"vegafusion\") \nimport matplotlib.pyplot as plt\nimport panel as pn\npn.extension()\n\nfrom shapely.geometry import Point\nfrom sklearn.preprocessing import MinMaxScaler\nfrom scipy.spatial import cKDTree\nfrom pulp import LpMaximize, LpProblem, LpVariable, lpSum\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.2 Establish Universal Coordinate Reference System for Philadelphia\nadd text here explining what this is\n\nphl_crs = 2272  # EPSG:2272\n\n\n\n1.3 Data Overview\nGraphic explaining data\ngeojson for gep data csv for tabular records\nProperty Assesments: ‚Äúparcel geometry, land use, assessed land/building value, year built, lot size‚Äù\n\n\n1.4 Data Onboarding\nEach data set is read in via geopandas data frames and converted to a Philadelphia coordinate refernce syetem.\n\n\n# 1.1 Property Assessments (Parcels)\nproperty_assessment_info = gpd.read_file(\n    \"data/opa_properties_public.geojson\" \n).to_crs(phl_crs)\n\n# 1.2 Vacant Property Indicators\nvacant_property_indicators = gpd.read_file(\n    \"data/Vacant_Indicators_Land.geojson\"  \n).to_crs(phl_crs)\n\n# 1.3 Zoning Base Districts\nzoning_districts = gpd.read_file(\n    \"data/Zoning_BaseDistricts.geojson\"  \n).to_crs(phl_crs)\n\n# 1.4 Zoning Overlays\nzoning_overlays = gpd.read_file(\n    \"data/Zoning_Overlays.geojson\"  \n).to_crs(phl_crs)\n\n# 1.5 Permits (Building & Zoning)\npermit_data = pd.read_csv(\n    \"/Users/JoshuaRigsby 1/Desktop/permits.csv\")\n\n# 1.6 Real estate transfers (Sales)\nsales_transfers_data = pd.read_csv(\n    \"data/RTT_SUMMARY.csv\"  \n)\n\n# 1.6 (Optional) ACS data\n# acs = cny.products.APIConnection(\"ACSDT5Y2022\").query_variables([...])\n# ... etc, only if you decide to add it.\n\n/var/folders/qr/r5tzr37x24vf63l6k50wvx_c0000gn/T/ipykernel_88100/178185175.py:26: DtypeWarning: Columns (26,34,39) have mixed types. Specify dtype option on import or set low_memory=False.\n  sales_transfers_data = pd.read_csv(\n\n\n\n\n1.4.2 Data Onboarding - Parcels via seperate pipeline for efficiency\n\n# 1.7 Parcel Geometry\nparcel_geometry = gpd.read_file(\n    \"data/DOR_Parcel.geojson\"  \n).to_crs(phl_crs)\n\n\n#parcel_geometry.head()\n\n\n#property_assessment_info.head()\n\n\n#vacant_property_indicators.head()\n\n\n#zoning_districts.head()\n\n\n#zoning_overlays.head\n\n\n#permit_data.head()\n\n\n#sales_transfers_data.head()\n\n\n\n1.5 Data Processing and Preparation\nEach dataset contains different id‚Äôs and geometries, so the data underwent a normalization into a common baseline to prepare the data to joined, analyzied and computed.\nData Processing by Data Set\nProperty Assessments\nThe pin variable was renamed to PARCEL_ID for consistency across datasets, market_value, total_livable_area, and year_built were renamed to standardized variable names to be used in feature engineering for computing value gap, build ratio, and depreciation. A tag was added to track the dataset origin. The data was reprojected to EPSG:2272 as a redundant but safe measure. Only geometries that exist were kept because the dataset uses point geometries rather than full polygons, and later they are spatially joined to zoning and vacant-parcel polygons.\nVacant Property Indicators\nThe opa_id variable was renamed to PARCEL_ID for consistency across datasets. A VACANT_FLAG = 1 column was added for filtering. only essential variables were kept: the parcel ID, zoning info, flag, and geometry. The data was reprojected to EPSG:2272 as a redundant but safe measure.\nZoning Base Districts\nColumn names were simplified so so ZONE_TYPE can be analysed more efficiently. Only variables relevant for joining to parcels were kept: the zoning label, and geometry. The data was reprojected to EPSG:2272 as a redundant but safe measure.\nZoning Overlays\nThe overlay_symbol variable was renamed to OVERLAY_TYPE for consistenty, only theoverlay ID and geometry, were kept as most of the overlay attributes are legal text not needed. The data was reprojected to EPSG:2272 as a redundant but safe measure.\nBuilding and Zoning Permits\nPermit id‚Äôs and types were standardized and renamed into concise variable names, only columns useful for tracking recent or active redevelopments were kept. Duplicates were erased to ensure one record per permit.\nReal Estate Transfers\nSale date and price were converted to numeric types. All zero or null sales were removed. Only the most recent sale for each parcel was kept\nOverview\n\nEvery dataset has consistent IDs :PARCEL_ID\nAll geometries share the same coordinate refernce system (EPSG:2272).\nIrrelevant or redundant columns removed.\nData types are properly formatted for numeric and date operations.\nEach dataset is prepared for a clear role in the modeling operation\n\nproperty_assessment_info_cleaned: Financial & physical base data\nvacant_property_indicators_cleaned: Redevelopment candidate footprints\nzoning_districts_cleaned and zoning_overlays_cleaned: Regulatory context\npermit_data_cleaned: Project filter\nsales_transfers_data_cleaned: Market value benchmark\n\n\n# Property Assessments (Parcels)\nproperty_assessment_info_cleaned = (\n    property_assessment_info.rename(columns={   \n        \"pin\": \"PARCEL_ID\",\n        \"total_livable_area\": \"BUILDING_SQFT\",\n        \"market_value\": \"ASSESSED_VALUE\",\n        \"year_built\": \"YEAR_BUILT\"\n    })\n    .assign(SOURCE=\"Assessments\")\n    .to_crs(phl_crs)\n)\n\nproperty_assessment_info_cleaned = property_assessment_info_cleaned[\n    property_assessment_info_cleaned.geometry.notna()\n]\n\n\n# Vacant Property Indicators\nvacant_property_indicators_cleaned = (\n    vacant_property_indicators.rename(columns={       \n        \"opa_id\": \"PARCEL_ID\",\n        \"zoningbasedistrict\": \"ZONE_BASE\"\n    })\n    .assign(VACANT_FLAG=1)\n)[[\"PARCEL_ID\", \"ZONE_BASE\", \"VACANT_FLAG\", \"geometry\"]].to_crs(phl_crs)\n\n\n# Zoning Base Districts\nzoning_districts_cleaned = zoning_districts.rename(columns={\"code\": \"ZONE_TYPE\"})[\n    [\"ZONE_TYPE\", \"geometry\"]\n].to_crs(phl_crs)\n\n\n# Zoning Overlays\nzoning_overlays_cleaned = zoning_overlays.rename(columns={\"overlay_symbol\": \"OVERLAY_TYPE\"})[\n    [\"OVERLAY_TYPE\", \"geometry\"]\n].to_crs(phl_crs)\n\n\n# Permits (Building & Zoning)\npermit_data_cleaned = (\n    permit_data.rename(columns={                 \n        \"parcel_id_num\": \"PARCEL_ID\",\n        \"permitnumber\": \"PERMIT_NUMBER\",\n        \"permittype\": \"PERMIT_TYPE\",\n        \"typeofwork\": \"WORK_TYPE\",\n        \"approvedscopeofwork\": \"SCOPE\",\n        \"commercialorresidential\": \"PROJECT_USE\"\n    })\n)\n\n# Keep lat lng to build geometry\npermit_data_cleaned = permit_data_cleaned[\n    [\"PARCEL_ID\", \"PERMIT_NUMBER\", \"PERMIT_TYPE\",\n     \"WORK_TYPE\", \"SCOPE\", \"PROJECT_USE\",\n     \"lat\", \"lng\"]\n]\n\n# Drop duplicate permits\npermit_data_cleaned = permit_data_cleaned.drop_duplicates(subset=[\"PERMIT_NUMBER\"])\n\n\n# Real Estate Transfers (Sales)\nsales_transfers_data_cleaned = (\n    sales_transfers_data.rename(columns={        \n        \"opa_account_num\": \"PARCEL_ID\",\n        \"cash_consideration\": \"SALE_PRICE\",\n        \"display_date\": \"SALE_DATE\"\n    })\n)[[\"PARCEL_ID\", \"SALE_DATE\", \"SALE_PRICE\", \"lat\", \"lng\"]]   # KEEP lat/lng HERE ‚úî\n\nsales_transfers_data_cleaned[\"SALE_DATE\"] = pd.to_datetime(\n    sales_transfers_data_cleaned[\"SALE_DATE\"], errors=\"coerce\"\n)\nsales_transfers_data_cleaned[\"SALE_PRICE\"] = pd.to_numeric(\n    sales_transfers_data_cleaned[\"SALE_PRICE\"], errors=\"coerce\"\n)\n\n# Remove $1 deeds and invalid sales\nsales_transfers_data_cleaned = sales_transfers_data_cleaned[\n    sales_transfers_data_cleaned[\"SALE_PRICE\"] &gt; 1000\n]\n\n\n# Convert Sales to GeoDataFrame using correctly preserved lat/lng\nsales_gdf = gpd.GeoDataFrame(\n    sales_transfers_data_cleaned,\n    geometry=gpd.points_from_xy(\n        sales_transfers_data_cleaned[\"lng\"],\n        sales_transfers_data_cleaned[\"lat\"],\n        crs=\"EPSG:4326\"\n    )\n).to_crs(phl_crs)\n\n\n# Spatial Join match each sale to nearest parcel\nsales_joined = gpd.sjoin_nearest(\n    property_assessment_info_cleaned[[\"PARCEL_ID\", \"geometry\"]],\n    sales_gdf,\n    how=\"left\",\n    distance_col=\"DISTANCE_TO_SALE\"\n)\n\nsales_joined = sales_joined.rename(columns={\"PARCEL_ID_left\": \"PARCEL_ID\"})\nsales_joined = sales_joined.drop(columns=[\"PARCEL_ID_right\"], errors=\"ignore\")\n\n\n# Keep most recent sale for each parcel\nsales_joined = (\n    sales_joined.sort_values(\"SALE_DATE\")\n    .groupby(\"PARCEL_ID\")\n    .tail(1)\n)\n\nparcel_sales_cleaned = sales_joined[\n    [\"PARCEL_ID\", \"SALE_DATE\", \"SALE_PRICE\"]\n].dropna(subset=[\"SALE_PRICE\"])\n\n\n# Summary\nprint(\"‚úÖ Cleaned Datasets:\")\nfor name, df in {\n    \"Property Assessments\": property_assessment_info_cleaned,\n    \"Vacant Parcels\": vacant_property_indicators_cleaned,\n    \"Zoning Base\": zoning_districts_cleaned,\n    \"Zoning Overlays\": zoning_overlays_cleaned,\n    \"Permits\": permit_data_cleaned,\n    \"Sales\": parcel_sales_cleaned\n}.items():\n    print(f\"{name:&lt;20}: {len(df)} records\")\n\n\n‚úÖ Cleaned Datasets:\nProperty Assessments: 583639 records\nVacant Parcels      : 28932 records\nZoning Base         : 29161 records\nZoning Overlays     : 193 records\nPermits             : 895440 records\nSales               : 583639 records\n\n\n\n#property_assessment_info_cleaned.head() \n\n\n#vacant_property_indicators_cleaned.head()\n\n\n#zoning_districts_cleaned.head()\n\n\n#zoning_overlays_cleaned.head()\n\n\n#permit_data_cleaned.head()\n\n\n#parcel_sales_cleaned.head()\n\n#1. Data onboarding, Data Preparation and Feature Engineering\nMaybe add subtitle"
  },
  {
    "objectID": "final_project.html#exploratory-data-analysis",
    "href": "final_project.html#exploratory-data-analysis",
    "title": "Development Opportunity Optimizer",
    "section": "2. Exploratory Data Analysis",
    "text": "2. Exploratory Data Analysis\nMaybe add subtitle can do explanations later\n\n2.1 Data Aggregation for Visual Production\nadd explanation here\n\n# EDA Data Set 1\neda_data = property_assessment_info_cleaned.merge(\n    parcel_sales_cleaned,\n    on=\"PARCEL_ID\",\n    how=\"left\"\n)\n\n# EDA Data Set 2\neda_data_2 = property_assessment_info_cleaned.merge(\n    parcel_sales_cleaned,\n    on=\"PARCEL_ID\",\n    how=\"inner\"\n)\n\n# Drop rows missing required values\neda_data_clean = eda_data_2.dropna(subset=[\"ASSESSED_VALUE\", \"SALE_PRICE\"])\n\n\n\n2.1.2 Data Aggregation for Visual Production - Cleaning Parcel Data\nadd explanation here\nOver 15 million parcels exist so data cleaning and processing was split into two steps. The earlier step cleaned all other data and this step cleans and joins parcels to the other data sets.\n\n\n# Data Cleaning DOR Parcel data and Joining Parcels to Other Data Sets\n\n# CRS\nprint(\"STEP 1: CRS...\")\ndor_parcels = parcel_geometry.to_crs(phl_crs).copy()\nprint(\"‚úî STEP 1 done:\", len(dor_parcels), \"DOR parcels\")\n\n# OPA columns to attach to polygons\nprint(\"STEP 2: OPA columns to attach to polygons...\")\nopa_for_join = property_assessment_info_cleaned[\n    [\"PARCEL_ID\", \"ASSESSED_VALUE\", \"BUILDING_SQFT\",\n     \"YEAR_BUILT\", \"geometry\"]\n].copy()\nopa_for_join[\"PARCEL_ID\"] = opa_for_join[\"PARCEL_ID\"].astype(str)\nprint(\"‚úî STEP 2 done:\", len(opa_for_join), \"OPA records\")\n\n# Spatial join, assign OPA points to DOR polygons\nprint(\"STEP 3: Spatial join...\")\nparcels = gpd.sjoin_nearest(\n    dor_parcels,\n    opa_for_join,\n    how=\"left\",\n    distance_col=\"JOIN_DIST\"\n).drop(columns=[\"index_right\"], errors=\"ignore\")\nprint(\"‚úî STEP 3 done:\", parcels[\"PARCEL_ID\"].notna().sum(), \"OPA matches\")\n\n# Consistent PARCEL_ID type for joins\nparcels[\"PARCEL_ID\"] = parcels[\"PARCEL_ID\"].astype(\"Int64\").astype(str)\nprint(\"‚úî STEP 3 PARCEL_ID normalized back to string\")\n\n# Change sales data PARCEL_ID to a string\nparcel_sales_cleaned[\"PARCEL_ID\"] = parcel_sales_cleaned[\"PARCEL_ID\"].astype(str)\n\n# Join Sales\nprint(\"STEP 4: Join Sales...\")\nparcels = parcels.merge(\n    parcel_sales_cleaned[[\"PARCEL_ID\", \"SALE_DATE\", \"SALE_PRICE\"]],\n    on=\"PARCEL_ID\",\n    how=\"left\"\n)\nprint(\"‚úî STEP 4 done:\", parcels[\"SALE_PRICE\"].notna().sum(), \"parcels with sales\")\n\n# Vacant Property Indicators\nprint(\"STEP 5: Join Vacancy...\")\n\nvacant_property_indicators_cleaned = (\n    vacant_property_indicators.rename(columns={       \n        \"opa_id\": \"OPA_ID\",\n        \"zoningbasedistrict\": \"ZONE_BASE\"\n    })\n    .assign(VACANT_FLAG=1)\n)[[\"OPA_ID\", \"ZONE_BASE\", \"VACANT_FLAG\", \"geometry\"]].to_crs(phl_crs)\n\n# Any overlap with a vacant polygon, VACANT_FLAG = 1\nvac_join = gpd.sjoin(\n    parcels,\n    vacant_property_indicators_cleaned[[\"VACANT_FLAG\", \"geometry\"]],\n    how=\"left\",\n    predicate=\"intersects\"\n).drop(columns=[\"index_right\"], errors=\"ignore\")\n\nvac_join[\"VACANT_FLAG\"] = vac_join[\"VACANT_FLAG\"].fillna(0).astype(int)\nparcels = vac_join\nprint(\"‚úî STEP 5 done:\", parcels[\"VACANT_FLAG\"].sum(), \"vacant parcels\")\n\n# Join Permit Counts\nprint(\"STEP 6: Synthetic permit counts...\")\n\n# set seed for reproducibility\nnp.random.seed(42)\n\n# Poisson(0.3) parcels have 0 permits, some have 1‚Äì2, a few higher\nparcels[\"PERMIT_COUNT\"] = np.random.poisson(lam=0.3, size=len(parcels)).astype(int)\n\nprint(\"‚úî STEP 6 done: PERMIT_COUNT created\")\nprint(\"    min:\", parcels[\"PERMIT_COUNT\"].min(),\n      \"max:\", parcels[\"PERMIT_COUNT\"].max(),\n      \"mean:\", parcels[\"PERMIT_COUNT\"].mean())\n\n# Zoning and Spatial Joins\nprint(\"STEP 7: Zoning bounding boxes...\")\nparcels[\"bbox_geom\"] = parcels.geometry.envelope\nzoning_districts_cleaned[\"bbox_geom\"] = zoning_districts_cleaned.geometry.envelope\nprint(\"‚úî STEP 7 done: bounding boxes created\")\n\nprint(\"STEP 8: Base zoning join...\")\nparcels = gpd.sjoin(\n    parcels.set_geometry(\"bbox_geom\"),\n    zoning_districts_cleaned.set_geometry(\"bbox_geom\")[[\"ZONE_TYPE\", \"bbox_geom\"]],\n    how=\"left\",\n    predicate=\"intersects\"\n).rename(columns={\"ZONE_TYPE\": \"BASE_ZONE\"}).drop(columns=[\"index_right\"], errors=\"ignore\")\nprint(\"‚úî STEP 8 done:\", parcels[\"BASE_ZONE\"].notna().sum(), \"parcels with base zoning\")\n\n\n# Restore original parcel polygon geometry\nparcels = parcels.set_geometry(\"geometry\")\n\n# Final Parcel Data\nparcels_for_eda = parcels.copy()\n\nprint(\"üéâ parcels_for_eda created successfully!\")\nprint(\"Total parcels:\", len(parcels_for_eda))\nprint(\"Columns:\", list(parcels_for_eda.columns))\n\n\nSTEP 1: CRS...\n‚úî STEP 1 done: 607378 DOR parcels\nSTEP 2: OPA columns to attach to polygons...\n‚úî STEP 2 done: 583639 OPA records\nSTEP 3: Spatial join...\n‚úî STEP 3 done: 721517 OPA matches\n‚úî STEP 3 PARCEL_ID normalized back to string\nSTEP 4: Join Sales...\n‚úî STEP 4 done: 721517 parcels with sales\nSTEP 5: Join Vacancy...\n‚úî STEP 5 done: 144430 vacant parcels\nSTEP 6: Synthetic permit counts...\n‚úî STEP 6 done: PERMIT_COUNT created\n    min: 0 max: 6 mean: 0.3003516835984114\nSTEP 7: Zoning bounding boxes...\n‚úî STEP 7 done: bounding boxes created\nSTEP 8: Base zoning join...\n‚úî STEP 8 done: 2463946 parcels with base zoning\nüéâ parcels_for_eda created successfully!\nTotal parcels: 2464368\nColumns: ['recsub', 'basereg', 'mapreg', 'parcel', 'recmap', 'stcod', 'house', 'suf', 'unit', 'stex', 'stdir', 'stnam', 'stdessuf', 'elev_flag', 'topelev', 'botelev', 'condoflag', 'matchflag', 'inactdate', 'orig_date', 'status', 'geoid', 'stdes', 'addr_source', 'addr_std', 'comments', 'pin', 'frac', 'unit_type', 'stex_frac', 'stex_suf', 'separated_rights', 'muniment_type', 'muniment_id', 'dor_review', 'opa_review', 'pwd_review', 'objectid', 'Shape__Area', 'Shape__Length', 'geometry', 'PARCEL_ID', 'ASSESSED_VALUE', 'BUILDING_SQFT', 'YEAR_BUILT', 'JOIN_DIST', 'SALE_DATE', 'SALE_PRICE', 'VACANT_FLAG', 'PERMIT_COUNT', 'bbox_geom', 'BASE_ZONE']\n\n\n\n\n2.2 Assessed Value vs.¬†Sale Price\nFigure 1\nadd lots of info here\n\n\n# Merge assessments with the cleaned sales table\nmerged_sales = property_assessment_info_cleaned.merge(\n    parcel_sales_cleaned,      \n    on=\"PARCEL_ID\",\n    how=\"inner\"\n)\n\n# Interactive scatterplot: Assessed vs Actual Sale Price\nfig1 = merged_sales.hvplot.scatter(\n    x=\"ASSESSED_VALUE\",\n    y=\"SALE_PRICE\",\n    alpha=0.5,\n    size=5,\n    color=\"#00ff88\",            # bright green points\n    bgcolor=\"black\",            # dark theme\n    xlabel=\"Assessed Value ($)\",\n    ylabel=\"Sale Price ($)\",\n    title=\"Assessed Value vs. Sale Price\"\n).opts(fontsize={'title':14, 'labels':12})\n\nfig1\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[8], line 2\n      1 # Merge assessments with the cleaned sales table\n----&gt; 2 merged_sales = property_assessment_info_cleaned.merge(\n      3     parcel_sales_cleaned,      \n      4     on=\"PARCEL_ID\",\n      5     how=\"inner\"\n      6 )\n      8 # Interactive scatterplot: Assessed vs Actual Sale Price\n      9 fig1 = merged_sales.hvplot.scatter(\n     10     x=\"ASSESSED_VALUE\",\n     11     y=\"SALE_PRICE\",\n   (...)     18     title=\"Assessed Value vs. Sale Price\"\n     19 ).opts(fontsize={'title':14, 'labels':12})\n\nFile /Applications/anaconda3/envs/geospatial/lib/python3.13/site-packages/pandas/core/frame.py:10859, in DataFrame.merge(self, right, how, on, left_on, right_on, left_index, right_index, sort, suffixes, copy, indicator, validate)\n  10840 @Substitution(\"\")\n  10841 @Appender(_merge_doc, indents=2)\n  10842 def merge(\n   (...)  10855     validate: MergeValidate | None = None,\n  10856 ) -&gt; DataFrame:\n  10857     from pandas.core.reshape.merge import merge\n&gt; 10859     return merge(\n  10860         self,\n  10861         right,\n  10862         how=how,\n  10863         on=on,\n  10864         left_on=left_on,\n  10865         right_on=right_on,\n  10866         left_index=left_index,\n  10867         right_index=right_index,\n  10868         sort=sort,\n  10869         suffixes=suffixes,\n  10870         copy=copy,\n  10871         indicator=indicator,\n  10872         validate=validate,\n  10873     )\n\nFile /Applications/anaconda3/envs/geospatial/lib/python3.13/site-packages/pandas/core/reshape/merge.py:170, in merge(left, right, how, on, left_on, right_on, left_index, right_index, sort, suffixes, copy, indicator, validate)\n    155     return _cross_merge(\n    156         left_df,\n    157         right_df,\n   (...)    167         copy=copy,\n    168     )\n    169 else:\n--&gt; 170     op = _MergeOperation(\n    171         left_df,\n    172         right_df,\n    173         how=how,\n    174         on=on,\n    175         left_on=left_on,\n    176         right_on=right_on,\n    177         left_index=left_index,\n    178         right_index=right_index,\n    179         sort=sort,\n    180         suffixes=suffixes,\n    181         indicator=indicator,\n    182         validate=validate,\n    183     )\n    184     return op.get_result(copy=copy)\n\nFile /Applications/anaconda3/envs/geospatial/lib/python3.13/site-packages/pandas/core/reshape/merge.py:807, in _MergeOperation.__init__(self, left, right, how, on, left_on, right_on, left_index, right_index, sort, suffixes, indicator, validate)\n    803 self._validate_tolerance(self.left_join_keys)\n    805 # validate the merge keys dtypes. We may need to coerce\n    806 # to avoid incompatible dtypes\n--&gt; 807 self._maybe_coerce_merge_keys()\n    809 # If argument passed to validate,\n    810 # check if columns specified as unique\n    811 # are in fact unique.\n    812 if validate is not None:\n\nFile /Applications/anaconda3/envs/geospatial/lib/python3.13/site-packages/pandas/core/reshape/merge.py:1509, in _MergeOperation._maybe_coerce_merge_keys(self)\n   1503     # unless we are merging non-string-like with string-like\n   1504     elif (\n   1505         inferred_left in string_types and inferred_right not in string_types\n   1506     ) or (\n   1507         inferred_right in string_types and inferred_left not in string_types\n   1508     ):\n-&gt; 1509         raise ValueError(msg)\n   1511 # datetimelikes must match exactly\n   1512 elif needs_i8_conversion(lk.dtype) and not needs_i8_conversion(rk.dtype):\n\nValueError: You are trying to merge on int32 and object columns for key 'PARCEL_ID'. If you wish to proceed you should use pd.concat\n\n\n\n\n\n2.3 Statistical Association of Financial Variables - Correlation Matrix\nFigure 2\nadd lots of info here\n\n# Numeric proxy for correlation analysis\nnum_df = merged_sales[[\"ASSESSED_VALUE\", \"SALE_PRICE\", \"BUILDING_SQFT\", \"YEAR_BUILT\"]].dropna()\n\n# Black theme\nplt.style.use(\"dark_background\") \n\n# Heatmap showing correlations among real estate variables\nplt.figure(figsize=(7,6))\nsns.heatmap(\n    num_df.corr(),\n    cmap=\"Greens\",      # green colors\n    annot=True,         # show correlation numbers\n    linewidths=0.5\n)\n\nplt.title(\"Correlation Matrix of Key Variables\", color=\"white\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n2.4 Statistical Association of Market Gap - Correlation Matrix\nFigure 3\nadd lots of info here\n\n\nplt.style.use(\"dark_background\")\nplt.figure(figsize=(6,4))\n\nsns.heatmap(\n    eda_data[[\"ASSESSED_VALUE\", \"SALE_PRICE\"]].dropna().corr(),\n    annot=True,\n    cmap=\"Greens\",\n    linewidths=0.5\n)\n\nplt.title(\"Correlation Between Assessed Value and Sale Price\", color=\"white\")\nplt.show()\n\n\n\n\n\n\n\n\n\n## add tracts and borders\nm_vac = folium.Map(\n    location=[39.99, -75.13],\n    zoom_start=11,\n    tiles=xyzservices.providers.CartoDB.DarkMatter\n)\n\n# Convert to WGS84 and get centroid coords\nvac_df = vacant_property_indicators_cleaned.copy()\nvac_df = vac_df.to_crs(epsg=4326)\n\nvac_df[\"lat\"] = vac_df.geometry.centroid.y\nvac_df[\"lng\"] = vac_df.geometry.centroid.x\n\n# Plot samples so map isn't overloaded\nfor _, row in vac_df.sample(3000).iterrows():\n    folium.CircleMarker(\n        location=[row[\"lat\"], row[\"lng\"]],\n        radius=1,\n        color=\"#00ff88\",\n        fill=True,\n        fill_opacity=0.8\n    ).add_to(m_vac)\n\nm_vac\n\n/var/folders/qr/r5tzr37x24vf63l6k50wvx_c0000gn/T/ipykernel_57419/1983197717.py:11: UserWarning: Geometry is in a geographic CRS. Results from 'centroid' are likely incorrect. Use 'GeoSeries.to_crs()' to re-project geometries to a projected CRS before this operation.\n\n  vac_df[\"lat\"] = vac_df.geometry.centroid.y\n/var/folders/qr/r5tzr37x24vf63l6k50wvx_c0000gn/T/ipykernel_57419/1983197717.py:12: UserWarning: Geometry is in a geographic CRS. Results from 'centroid' are likely incorrect. Use 'GeoSeries.to_crs()' to re-project geometries to a projected CRS before this operation.\n\n  vac_df[\"lng\"] = vac_df.geometry.centroid.x\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n# Geometry and Sales info\nsales_map_df = property_assessment_info_cleaned.merge(\n    parcel_sales_cleaned,\n    on=\"PARCEL_ID\",\n    how=\"inner\"\n)\n\n# Reproject to WGS84 for Folium\nsales_map_df = sales_map_df.to_crs(epsg=4326)\n\n# Extract lat/lng\nsales_map_df[\"lat\"] = sales_map_df.geometry.y\nsales_map_df[\"lng\"] = sales_map_df.geometry.x\n\n# Map\nm_sales = folium.Map(\n    location=[39.99, -75.13],\n    zoom_start=11,\n    tiles=xyzservices.providers.CartoDB.DarkMatter\n)\n\n# Add points in samples\nfor _, row in sales_map_df.sample(3000).iterrows():\n    folium.CircleMarker(\n        location=[row[\"lat\"], row[\"lng\"]],\n        radius=1,          \n        color=\"#00ff88\",\n        fill=True,\n        fill_opacity=0.7\n    ).add_to(m_sales)\n\nm_sales\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n\n# Clip extreme outliers for visualization\neda_filtered = eda_data_clean[\n    (eda_data_clean[\"ASSESSED_VALUE\"] &lt; 2_000_000) &\n    (eda_data_clean[\"SALE_PRICE\"] &lt; 2_000_000)\n]\n\n# Compute smart axis ranges from percentiles\nx_min = eda_filtered[\"ASSESSED_VALUE\"].quantile(0.01)\nx_max = eda_filtered[\"ASSESSED_VALUE\"].quantile(0.99)\n\ny_min = eda_filtered[\"SALE_PRICE\"].quantile(0.01)\ny_max = eda_filtered[\"SALE_PRICE\"].quantile(0.99)\n\nplt.style.use(\"dark_background\")\n\n# Hexbin plot with axis limits applied\ng = sns.jointplot(\n    data=eda_filtered,\n    x=\"ASSESSED_VALUE\",\n    y=\"SALE_PRICE\",\n    kind=\"hex\",\n    color=\"#00ff88\"\n)\n\n# Apply new zoomed-in limits so the data fills the plot\ng.ax_joint.set_xlim(x_min, x_max)\ng.ax_joint.set_ylim(y_min, y_max)\n\n# Also apply limits to histograms\ng.ax_marg_x.set_xlim(x_min, x_max)\ng.ax_marg_y.set_ylim(y_min, y_max)\n\nplt.suptitle(\"Hexbin Density: Assessed vs Sale Price\", color=\"white\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\neda_alt = (\n    eda_data\n    .dropna(subset=[\"ASSESSED_VALUE\", \"SALE_PRICE\"])\n    [[\"PARCEL_ID\", \"ASSESSED_VALUE\", \"SALE_PRICE\"]]  # keep only needed cols\n    .sample(5000, random_state=42)                   # &lt;= under Altair limit\n)\n\nfig5 = (\n    alt.Chart(eda_alt)\n    .mark_circle(size=12, opacity=0.4, color=\"#00ff88\")\n    .encode(\n        x=alt.X(\"ASSESSED_VALUE:Q\", title=\"Assessed Value ($)\", scale=alt.Scale(zero=False)),\n        y=alt.Y(\"SALE_PRICE:Q\", title=\"Sale Price ($)\", scale=alt.Scale(zero=False)),\n        tooltip=[\"PARCEL_ID\", \"ASSESSED_VALUE\", \"SALE_PRICE\"]\n    )\n    .properties(\n        width=600,\n        height=400,\n        title=\"Assessed Value vs Sale Price (Sample of 5,000 Parcels)\"\n    )\n)\n\nfig5. i\n\n\n\n\n\n\n\n\n\nparcel_map_base = (\n    parcels_for_eda\n    .drop_duplicates(subset=\"PARCEL_ID\", keep=\"first\")\n    .reset_index(drop=True)\n)\n\n\nimport datashader as ds\nimport datashader.transfer_functions as tf\n\n# -------------------------------------------------------------------\n# SAFE GREEN COLORMAP (works with your Datashader version)\n# -------------------------------------------------------------------\ngreen_cmap = [\n    \"#f7fcf5\",\n    \"#e5f5e0\",\n    \"#c7e9c0\",\n    \"#a1d99b\",\n    \"#74c476\",\n    \"#41ab5d\",\n    \"#238b45\",\n    \"#006d2c\",\n    \"#00441b\"\n]\n\n# -------------------------------------------------------------------\n# 1. Simplify polygons to avoid rendering crashes\n# -------------------------------------------------------------------\npoly_gdf = parcel_map_base.dropna(subset=[\"SALE_PRICE\"]).copy()\npoly_gdf[\"simple_geom\"] = poly_gdf.geometry.simplify(\n    tolerance=3,\n    preserve_topology=True\n)\npoly_gdf = poly_gdf.set_geometry(\"simple_geom\")\n\n# -------------------------------------------------------------------\n# 2. HIGH-RES Canvas (dramatically improves map clarity)\n# -------------------------------------------------------------------\nxmin, ymin, xmax, ymax = poly_gdf.total_bounds\n\ncvs = ds.Canvas(\n    plot_width=3600,\n    plot_height=2400,\n    x_range=(xmin, xmax),\n    y_range=(ymin, ymax)\n)\n\n# -------------------------------------------------------------------\n# 3. Polygon rasterization (mean SALE_PRICE per pixel)\n# -------------------------------------------------------------------\nagg = cvs.polygons(\n    poly_gdf,\n    geometry=\"simple_geom\",\n    agg=ds.mean(\"SALE_PRICE\")\n)\n\n# -------------------------------------------------------------------\n# 4. Colorize using histogram equalization (MUCH clearer contrast)\n# -------------------------------------------------------------------\nimg = tf.shade(\n    agg,\n    cmap=green_cmap,\n    how=\"eq_hist\"\n)\n\n# -------------------------------------------------------------------\n# 5. Spread pixels so parcels become clearly visible\n# -------------------------------------------------------------------\nimg = tf.spread(img, px=2)\n\nimg\n\n\n\n\n\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# ----------------------------------------------------\n# 1. Sample parcels (keeps performance FAST)\n# ----------------------------------------------------\n# Only keep parcels with sale price\nplot_data = parcels_for_eda.dropna(subset=[\"SALE_PRICE\"]).copy()\n\n# Set sample size (adjust if you want)\nSAMPLE_SIZE = 350000\n\nif len(plot_data) &gt; SAMPLE_SIZE:\n    plot_data = plot_data.sample(SAMPLE_SIZE, random_state=42)\n\nprint(\"Parcels being plotted:\", len(plot_data))\n\n# ----------------------------------------------------\n# 2. Set plot style\n# ----------------------------------------------------\nplt.style.use(\"dark_background\")   # fake dark basemap look\nfig, ax = plt.subplots(figsize=(12, 12))\nax.set_facecolor(\"black\")\nfig.patch.set_facecolor(\"black\")\n\n# ----------------------------------------------------\n# 3. Create a green gradient for sale price\n# ----------------------------------------------------\nprices = plot_data[\"SALE_PRICE\"]\ncmap = plt.cm.YlGn  # your green gradient\nnorm = plt.Normalize(vmin=prices.min(), vmax=prices.max())\n\n# ----------------------------------------------------\n# 4. Plot\n# ----------------------------------------------------\nplot_data.plot(\n    ax=ax,\n    column=\"SALE_PRICE\",\n    cmap=cmap,\n    linewidth=0,\n    alpha=0.9,\n    norm=norm,\n)\n\n# ----------------------------------------------------\n# 5. Colorbar + clean layout\n# ----------------------------------------------------\nsm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)\nsm._A = []\ncbar = fig.colorbar(sm, ax=ax, shrink=0.7)\ncbar.set_label(\"Sale Price ($)\", color=\"white\")\n\nax.set_title(\n    \"Sampled Parcel Sale Price Map (Green Gradient)\",\n    fontsize=16, color=\"white\"\n)\nax.set_axis_off()\n\nplt.show()\n\nParcels being plotted: 350000\n\n\n\n\n\n\n\n\n\n\nimport geopandas as gpd\nimport pandas as pd\nimport numpy as np\nimport hvplot.pandas\nfrom shapely.geometry import Point\n\n# --------------------------------------------------\n# 1. Work only with parcels that have sale prices\n# --------------------------------------------------\ndf = parcels_for_eda.dropna(subset=[\"SALE_PRICE\"]).copy()\nprint(\"Parcels w/ sale price:\", len(df))\n\n# --------------------------------------------------\n# 2. SAMPLE down to 25,000 (safe)\n# --------------------------------------------------\ndf = df.sample(25000, random_state=42).copy()\nprint(\"Sample size:\", len(df))\n\n# --------------------------------------------------\n# 3. Ensure CRS is lat/lon (EPSG:4326) for web tiles\n# --------------------------------------------------\nif df.crs.to_epsg() != 4326:\n    df = df.to_crs(epsg=4326)\nprint(\"CRS used:\", df.crs)\n\n# --------------------------------------------------\n# 4. Convert polygons ‚Üí centroids\n# --------------------------------------------------\ndf[\"centroid\"] = df.geometry.centroid\npoints = df.set_geometry(\"centroid\")\n\n# --------------------------------------------------\n# 5. Build the interactive hvplot map\n# --------------------------------------------------\nplot = points.hvplot.points(\n    x=\"centroid.x\",\n    y=\"centroid.y\",\n    geo=True,\n    tiles=\"CartoDark\",\n    color=\"SALE_PRICE\",\n    cmap=\"YlGn\",\n    hover_cols=[\"PARCEL_ID\", \"SALE_PRICE\"],\n    size=6,\n    alpha=0.9,\n    frame_width=900,\n    frame_height=650,\n    title=\"Philadelphia Parcels ‚Äî Sale Price (Sampled Centroids, Green Gradient)\"\n)\n\nplot\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\nParcels w/ sale price: 2464331\nSample size: 25000\nCRS used: EPSG:4326\n\n\n/var/folders/qr/r5tzr37x24vf63l6k50wvx_c0000gn/T/ipykernel_88100/2245365821.py:29: UserWarning: Geometry is in a geographic CRS. Results from 'centroid' are likely incorrect. Use 'GeoSeries.to_crs()' to re-project geometries to a projected CRS before this operation.\n\n  df[\"centroid\"] = df.geometry.centroid\n\n\n\n\n\n\n  \n\n\n\n\n\nimport geopandas as gpd\nimport pandas as pd\nimport numpy as np\nimport hvplot.pandas\nfrom shapely.geometry import Point\n\n# --------------------------------------------------\n# 1. Work only with parcels that have sale prices\n# --------------------------------------------------\ndf = parcels_for_eda.dropna(subset=[\"SALE_PRICE\"]).copy()\nprint(\"Parcels w/ sale price:\", len(df))\n\n# --------------------------------------------------\n# 2. SAMPLE down to 25,000 (safe)\n# --------------------------------------------------\ndf = df.sample(50000, random_state=42).copy()\nprint(\"Sample size:\", len(df))\n\n# --------------------------------------------------\n# 3. Ensure CRS is lat/lon (EPSG:4326) for web tiles\n# --------------------------------------------------\nif df.crs.to_epsg() != 4326:\n    df = df.to_crs(epsg=4326)\nprint(\"CRS used:\", df.crs)\n\n# --------------------------------------------------\n# 4. Convert polygons ‚Üí centroids\n# --------------------------------------------------\ndf[\"centroid\"] = df.geometry.centroid\npoints = df.set_geometry(\"centroid\")\n\n# --------------------------------------------------\n# 5. Build the interactive hvplot map\n# --------------------------------------------------\nplot = points.hvplot.points(\n    x=\"centroid.x\",\n    y=\"centroid.y\",\n    geo=True,\n    tiles=\"CartoDark\",\n    color=\"SALE_PRICE\",\n    cmap=\"YlGn\",\n    hover_cols=[\"PARCEL_ID\", \"SALE_PRICE\"],\n    size=6,\n    alpha=0.9,\n    frame_width=900,\n    frame_height=650,\n    title=\"Philadelphia Parcels ‚Äî Sale Price (Sampled Centroids, Green Gradient)\"\n)\n\nplot\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\nParcels w/ sale price: 2464331\nSample size: 50000\nCRS used: EPSG:4326\n\n\n/var/folders/qr/r5tzr37x24vf63l6k50wvx_c0000gn/T/ipykernel_88100/1705510800.py:29: UserWarning: Geometry is in a geographic CRS. Results from 'centroid' are likely incorrect. Use 'GeoSeries.to_crs()' to re-project geometries to a projected CRS before this operation.\n\n  df[\"centroid\"] = df.geometry.centroid\n\n\n\n\n\n\n  \n\n\n\n\n\nimport geopandas as gpd\nimport pandas as pd\nimport numpy as np\nimport hvplot.pandas\nfrom shapely.geometry import Point\n\n# --------------------------------------------------\n# 1. Work only with parcels that have sale prices\n# --------------------------------------------------\ndf = parcels_for_eda.dropna(subset=[\"ASSESSED_VALUE\"]).copy()\nprint(\"Parcels w/ value:\", len(df))\n\n# --------------------------------------------------\n# 2. SAMPLE down to 25,000 (safe)\n# --------------------------------------------------\ndf = df.sample(50000, random_state=42).copy()\nprint(\"Sample size:\", len(df))\n\n# --------------------------------------------------\n# 3. Ensure CRS is lat/lon (EPSG:4326) for web tiles\n# --------------------------------------------------\nif df.crs.to_epsg() != 4326:\n    df = df.to_crs(epsg=4326)\nprint(\"CRS used:\", df.crs)\n\n# --------------------------------------------------\n# 4. Convert polygons ‚Üí centroids\n# --------------------------------------------------\ndf[\"centroid\"] = df.geometry.centroid\npoints = df.set_geometry(\"centroid\")\n\n# --------------------------------------------------\n# 5. Build the interactive hvplot map\n# --------------------------------------------------\nplot = points.hvplot.points(\n    x=\"centroid.x\",\n    y=\"centroid.y\",\n    geo=True,\n    tiles=\"CartoDark\",\n    color=\"ASSESSED_VALUE\",\n    cmap=\"YlGn\",\n    hover_cols=[\"PARCEL_ID\", \"ASSESSED_VALUE\"],\n    size=6,\n    alpha=0.9,\n    frame_width=900,\n    frame_height=650,\n    title=\"Philadelphia Parcels ‚Äî Assessed Value\"\n)\n\nplot\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\nParcels w/ value: 2464262\nSample size: 50000\nCRS used: EPSG:4326\n\n\n/var/folders/qr/r5tzr37x24vf63l6k50wvx_c0000gn/T/ipykernel_88100/3801669388.py:29: UserWarning: Geometry is in a geographic CRS. Results from 'centroid' are likely incorrect. Use 'GeoSeries.to_crs()' to re-project geometries to a projected CRS before this operation.\n\n  df[\"centroid\"] = df.geometry.centroid"
  },
  {
    "objectID": "final_project.html#financial-computations---mathematical-modeling-using-pulp",
    "href": "final_project.html#financial-computations---mathematical-modeling-using-pulp",
    "title": "Development Opportunity Optimizer",
    "section": "3. Financial Computations - Mathematical Modeling Using puLP",
    "text": "3. Financial Computations - Mathematical Modeling Using puLP\nMaybe add subtitle can do explanations later\nUses parcel_map_base (one row per parcel) Samples 5,000 candidate parcels Approximates buildable GFA using a simple FAR assumption Computes Revenue, Cost, Net Uplift Builds a binary optimization model that: Maximizes total net uplift Respects a total cost budget Limits the number of selected sites Returns a selected_parcels DataFrame\nOverview: Buildable GFA = lot_area √ó max_FAR ‚Üí we use lot_sqft * far_assumed Revenue = buildable_gfa √ó avg market price per sf ‚Üí market_price_sf Cost = buildable_gfa √ó construction cost per sf ‚Üí construction_cost_sf Net Value Uplift = Revenue ‚Äì Cost ‚àí assessed_value ‚Üí net_uplift Optimization: maximize net uplift under a budget constraint ‚Üí PuLP model\n\nPrepare the Mathematical DataFrame\nThis step creates a working copy of parcel_map_base and ensures numeric fields are clean. We do this to avoid solver errors due to strings, NaNs, or mixed dtypes.\nWe copy the deduplicated parcel dataset (parcel_map_base), ensure required columns are numeric (coercing errors to NaN), and prepare it for the next calculations.\nOur starting point is parcel_map_base, which is a one-row-per-parcel dataset constructed from: DOR parcel geometries OPA assessment data Sales, vacancy, and permit data\n\n\n# STEP 1 ‚Äî Prepare Mathematical Data Frame\ndf = parcel_map_base.copy()\n\n# Make key numeric fields are numeric for optimization\nnumeric_cols = [\"ASSESSED_VALUE\", \"BUILDING_SQFT\", \"SALE_PRICE\", \"PERMIT_COUNT\", \"VACANT_FLAG\"]\nfor col in numeric_cols:\n    if col in df.columns:\n        df[col] = pd.to_numeric(df[col], errors=\"coerce\")\n\nprint(\"Step 1 complete ‚Äî Mathematical DataFrame prepared.\")\n\nStep 1 complete ‚Äî Mathematical DataFrame prepared.\n\n\n\n\nComputing Financial Uplift Metrics\nThe core of the optimization model is a parcel-level estimate of redevelopment ‚Äúvalue uplift.‚Äù Following your proposal, we operationalize this through: Lot area (lot_sqft) Derived directly from the parcel geometry. Since the CRS is EPSG:2272 (feet), area is in square feet. This approximates the developable site area. Buildable gross floor area (buildable_gfa)\nBuildable GFA = lot area x max FAR\nIn the absence of joined zoning polygons (to keep runtime manageable), we use a constant assumed FAR as a pragmatic approximation of zoning capacity. This is explicitly an assumption and can be parameterized (e.g., FAR = 2.0). Revenue and cost estimates We then approximate development economics with two per-square-foot assumptions: market_price_sf ‚Äî average revenue per built square foot (e.g., $350/sf).\nconstruction_cost_sf all-in development cost per square foot (e.g., $250/sf). These are stylized but consistent with the notion of a screening model rather than a detailed pro forma.\nRevenue(i) - Buildable GFA(i) x p(market)\nCost(i) = Buildable GFA(i) x c(construction)\nNet value uplift (net_uplift) Finally, we define the uplift metric as in your document:\nNet Uplift(i) = Revenue(i) - Cost(i) - Assesed Value(i)\nthis is how much incremental value could be created above current assessed value, after covering construction costs.\n\n\n# STEP 2 ‚Äî Compute Finacial Uplift Metrics\n\n# Lot size from geometry (EPSG:2272)\ndf[\"lot_sqft\"] = df.geometry.area\n\n# FAR assumption - capacity proxy\nfar_assumed = 1.0  # can adjust later\ndf[\"buildable_gfa\"] = df[\"lot_sqft\"] * far_assumed\n\n# Replace missing assessed values with 0\ndf[\"ASSESSED_VALUE\"] = df[\"ASSESSED_VALUE\"].fillna(0)\n\n# Market pricing assumptions\nmarket_price_sf = 350.0      # revenue per sqft\nconstruction_cost_sf = 250.0 # cost per sqft\n\n# Compute revenue and cost\ndf[\"revenue\"] = df[\"buildable_gfa\"] * market_price_sf\ndf[\"cost\"] = df[\"buildable_gfa\"] * construction_cost_sf\n\n# Net uplift\ndf[\"net_uplift\"] = df[\"revenue\"] - df[\"cost\"] - df[\"ASSESSED_VALUE\"]\n\nprint(\"Step 2 complete ‚Äî Finacial Uplift Metrics Computed.\")\n\nStep 2 complete ‚Äî Finacial Uplift Metrics Computed.\n\n\n\n\nDefining the Candidate Set for Optimization\nMILP solvers like CBC struggle when we include hundreds of thousands of binary decision variables. To keep the problem well-posed and computationally tractable, we restrict the optimization to a candidate subset of parcels.\nThe filtering logic is grounded in development logic:\nPositive buildable capacity We require buildable_gfa &gt; 0 to avoid degenerate sites.\nNo active permits Parcels with active or recent permits are likely already in the development pipeline. Including them would double-count projects and reduce the realism of the tool as a forward-looking screening mechanism.\nPositive net uplift We focus on parcels where the stylized pro forma suggests value creation, i.e., net_uplift &gt; 0. Sites with negative uplift are dominated and should not be selected under a rational objective.\nRandom sampling to 5,000 parcels To maintain a solvable mixed-integer problem, we sample a subset (e.g., 5,000 parcels). This is explicitly a computational compromise: one could increase sample size on more powerful hardware, but 5,000 is a defensible middle ground for demonstration.\n\n\n# STEP 3 ‚Äî Filter and Sample Cadidate Parcels\n\ncandidates = df.copy()\n\n# Must have buildable area\ncandidates = candidates[candidates[\"buildable_gfa\"] &gt; 0]\n\n# Exclude parcels already under redevelopment\ncandidates = candidates[candidates[\"PERMIT_COUNT\"].fillna(0) == 0]\n\n# Keep only parcels with positive uplift\ncandidates = candidates[candidates[\"net_uplift\"] &gt; 0]\n\n# Sample to 5000 parcels for PuLP\nsample_size = 20000\nif len(candidates) &gt; sample_size:\n    candidates = candidates.sample(sample_size, random_state=42)\n\ncandidates = candidates.reset_index(drop=True)\n\nprint(f\"Step 3 complete ‚Äî Using {len(candidates)} candidate parcels.\")\n\nStep 3 complete ‚Äî Using 20000 candidate parcels.\n\n\n\n\nBuild the PuLP Model and Decision Variables\nThe redevelopment screening problem is as a binary optimization model using PuLP:\nLet each candidate parcel (i) be associated with a binary decison variable x(i) {0,1}\nx(i) = 1 if the parcel (i) is selected as part of the redevelopment portfolio\nx(i) = 0 if not\nThe objective will later be to maximize total net uplift. PuLP provides a high-level Python interface to create such models, which are then passed to an underlying MILP solver (CBC by default).\n\n\n# STEP 4 ‚Äî Build the PuLP Model and Decision Variables\n\n\n# Create the optimization problem\nmodel = pulp.LpProblem(\"Parcel_Redevelopment_Optimizer\", pulp.LpMaximize)\n\n# Binary variables for each parcel\nx = pulp.LpVariable.dicts(\n    \"x\",\n    candidates.index.tolist(),\n    lowBound=0,\n    upBound=1,\n    cat=\"Binary\"\n)\n\nprint(\"Step 4 complete ‚Äî PuLP model defined and variables created.\")\n\nStep 4 complete ‚Äî PuLP model defined and variables created.\n\n\n\n\nMaximize Total Net Uplift\nThe optimization goal is to select a subset of parcels that maximizes cumulative net value uplift, subject to various constraints (budget, maximum number of sites, etc.).\nthe objective is:\nmax‚àë‚Äãxi‚Äã‚ãÖnet_uplift\nI is the set of candidate parcels. net_uplift i net_uplift i ‚Äã\nis defined in Step 2.\nThis is the direct mathematical implementation of the ‚Äúvalue uplift‚Äù\n\n\n# STEP 5 ‚Äî Maximize Total Uplift\n\nmodel += pulp.lpSum(\n    candidates.loc[i, \"net_uplift\"] * x[i] for i in candidates.index\n), \"Total_Net_Uplift\"\n\nprint(\"Step 5 complete ‚Äî Maximization function added.\")\n\nStep 5 complete ‚Äî Maximization function added.\n\n\n\n\nAdding Development Budget and Portfolio Size Constraints\nReal-world development decisions are not solely about maximizing value; they are constrained by capital availability and organizational capacity (e.g., how many projects a firm can realistically pursue).\nWe impose two key constraints: Capital budget constraint Let cost i ‚Äã\nbe the development cost for parcel i. We require:\n‚àë‚Äãxi‚Äã‚ãÖcosti‚Äã‚â§B\nWhere B is the total capital budget (e.g., $300M). This ensures the selected portfolio of projects is financially feasible at a portfolio level. Maximum number of sites We also constrain the number of simultaneously pursued projects:\n‚àë‚Äãxi‚Äã‚â§Nmax‚Äã\nWhere N max ‚Å° N max ‚Äã\ncaps the number of redevelopment sites (e.g., 100). This crudely proxies organizational limits, risk diversification, and phasing constraints. Both parameters (total_budget and max_sites) are scenario-dependent and can be varied for sensitivity analysis.\n\n\n# STEP 6 ‚Äî Add Constraints\n\n# Cannot be run more than once\nmodel.constraints.clear()\n\n# Budget constraint\ntotal_budget = 300_000_000  # $300M\nmodel += pulp.lpSum(\n    candidates.loc[i, \"cost\"] * x[i] for i in candidates.index\n) &lt;= total_budget, \"BudgetConstraint\"\n\n# Maximum number of selected sites\nmax_sites = 500\nmodel += pulp.lpSum(x[i] for i in candidates.index) &lt;= max_sites, \"MaxSitesConstraint\"\n\nmin_sites = 100   # pick at least 100 parcels\nmodel += pulp.lpSum(x[i] for i in candidates.index) &gt;= min_sites, \"MinSitesConstraint\"\n\n\nprint(\"Step 6 complete ‚Äî Constraints added.\")\n\nStep 6 complete ‚Äî Constraints added.\n\n\n\n\nSolve the Optimization Model\nPuLP‚Äôs interface utilizes the CBC MILP solver. CBC computes the integrality constraints to solve a continuous LP, then iteratively applies branch-and-bound and cutting-plane techniques to enforce integrality and converge to an optimal (or near-optimal) solution.\nKey outcomes to monitor: Solver status (e.g., ‚ÄúOptimal‚Äù, ‚ÄúInfeasible‚Äù, ‚ÄúUnbounded‚Äù)\nRuntime and node counts (help confirm that the problem is of manageable size)\nIn understandable terms: It is optimizing development scenarios per parcel.\n\n\n# STEP 7 ‚Äî Solve the Model\n\nprint(\"Solving optimization model...\")\nsolution_status = model.solve(pulp.PULP_CBC_CMD(msg=True))\nprint(\"Solver status:\", pulp.LpStatus[solution_status])\n\nprint(\"Step 7 complete ‚Äî Model solved.\")\n\nSolving optimization model...\nWelcome to the CBC MILP Solver \nVersion: 2.10.3 \nBuild Date: Dec 15 2019 \n\ncommand line - /Applications/anaconda3/envs/geospatial/lib/python3.13/site-packages/pulp/apis/../solverdir/cbc/osx/i64/cbc /var/folders/qr/r5tzr37x24vf63l6k50wvx_c0000gn/T/38eba014191d49f6b1e02285419d45dd-pulp.mps -max -timeMode elapsed -branch -printingOptions all -solution /var/folders/qr/r5tzr37x24vf63l6k50wvx_c0000gn/T/38eba014191d49f6b1e02285419d45dd-pulp.sol (default strategy 1)\nAt line 2 NAME          MODEL\nAt line 3 ROWS\nAt line 8 COLUMNS\nAt line 120009 RHS\nAt line 120013 BOUNDS\nAt line 140014 ENDATA\nProblem MODEL has 3 rows, 20000 columns and 60000 elements\nCoin0008I MODEL read with 0 errors\nOption for timeMode changed from cpu to elapsed\nContinuous objective value is 1.19504e+08 - 0.06 seconds\nCgl0004I processed model has 2 rows, 19057 columns (19057 integer (18749 of which binary)) and 38114 elements\nCbc0038I Initial state - 2 integers unsatisfied sum - 0.0164205\nCbc0038I Pass   1: suminf.    0.00965 (2) obj. -1.19448e+08 iterations 3\nCbc0038I Pass   2: suminf.    0.28619 (2) obj. -1.19281e+08 iterations 1\nCbc0038I Solution found of -1.19281e+08\nCbc0038I Branch and bound needed to clear up 2 general integers\nCbc0038I Full problem 2 rows 19057 columns, reduced to 2 rows 264 columns\nCbc0038I Cleaned solution of -1.19344e+08\nCbc0038I Before mini branch and bound, 19052 integers at bound fixed and 0 continuous\nCbc0038I Mini branch and bound improved solution from -1.19344e+08 to -1.19344e+08 (0.39 seconds)\nCbc0038I Round again with cutoff of -1.1936e+08\nCbc0038I Reduced cost fixing fixed 9901 variables on major pass 2\nCbc0038I Pass   3: suminf.    0.00965 (2) obj. -1.19448e+08 iterations 0\nCbc0038I Pass   4: suminf.    0.06572 (3) obj. -1.1936e+08 iterations 5\nCbc0038I Solution found of -1.1936e+08\nCbc0038I Branch and bound needed to clear up 3 general integers\nCbc0038I Full problem 3 rows 19057 columns, reduced to 3 rows 29 columns\nCbc0038I Mini branch and bound could not fix general integers\nCbc0038I No solution found this major pass\nCbc0038I Before mini branch and bound, 19050 integers at bound fixed and 0 continuous\nCbc0038I Full problem 2 rows 19057 columns, reduced to 2 rows 6 columns\nCbc0038I Mini branch and bound did not improve solution (0.51 seconds)\nCbc0038I After 0.51 seconds - Feasibility pump exiting with objective of -1.19344e+08 - took 0.19 seconds\nCbc0012I Integer solution of -1.1934437e+08 found by feasibility pump after 0 iterations and 0 nodes (0.51 seconds)\nCbc0038I Full problem 2 rows 19057 columns, reduced to 2 rows 5 columns\nCbc0013I At root node, 0 cuts changed objective from -1.1950354e+08 to -1.1950354e+08 in 1 passes\nCbc0014I Cut generator 0 (Probing) - 0 row cuts average 0.0 elements, 0 column cuts (0 active)  in 0.008 seconds - new frequency is -100\nCbc0014I Cut generator 1 (Gomory) - 0 row cuts average 0.0 elements, 0 column cuts (0 active)  in 0.001 seconds - new frequency is -100\nCbc0014I Cut generator 2 (Knapsack) - 0 row cuts average 0.0 elements, 0 column cuts (0 active)  in 0.001 seconds - new frequency is -100\nCbc0014I Cut generator 3 (Clique) - 0 row cuts average 0.0 elements, 0 column cuts (0 active)  in 0.000 seconds - new frequency is -100\nCbc0014I Cut generator 4 (MixedIntegerRounding2) - 0 row cuts average 0.0 elements, 0 column cuts (0 active)  in 0.003 seconds - new frequency is -100\nCbc0014I Cut generator 5 (FlowCover) - 0 row cuts average 0.0 elements, 0 column cuts (0 active)  in 0.001 seconds - new frequency is -100\nCbc0010I After 0 nodes, 1 on tree, -1.1934437e+08 best solution, best possible -1.1950354e+08 (1.18 seconds)\nCbc0012I Integer solution of -1.1941941e+08 found by DiveCoefficient after 32 iterations and 22 nodes (6.32 seconds)\nCbc0012I Integer solution of -1.1947726e+08 found by DiveCoefficient after 57 iterations and 40 nodes (7.64 seconds)\nCbc0038I Full problem 2 rows 19057 columns, reduced to 2 rows 6 columns\nCbc0038I Full problem 2 rows 19057 columns, reduced to 2 rows 2109 columns\nCbc0044I Reduced cost fixing - 2 rows, 2109 columns - restarting search\nCbc0012I Integer solution of -1.1947726e+08 found by Previous solution after 0 iterations and 0 nodes (7.81 seconds)\nCbc0038I Full problem 2 rows 2109 columns, reduced to 2 rows 6 columns\nCbc0031I 5 added rows had average density of 471.4\nCbc0013I At root node, 5 cuts changed objective from -1.1950354e+08 to -1.1950325e+08 in 10 passes\nCbc0014I Cut generator 0 (Probing) - 0 row cuts average 0.0 elements, 0 column cuts (0 active)  in 0.009 seconds - new frequency is -100\nCbc0014I Cut generator 1 (Gomory) - 1 row cuts average 1988.0 elements, 0 column cuts (0 active)  in 0.004 seconds - new frequency is -100\nCbc0014I Cut generator 2 (Knapsack) - 0 row cuts average 0.0 elements, 0 column cuts (0 active)  in 0.001 seconds - new frequency is -100\nCbc0014I Cut generator 3 (Clique) - 0 row cuts average 0.0 elements, 0 column cuts (0 active)  in 0.000 seconds - new frequency is -100\nCbc0014I Cut generator 4 (MixedIntegerRounding2) - 2 row cuts average 1988.0 elements, 0 column cuts (0 active)  in 0.006 seconds - new frequency is 1\nCbc0014I Cut generator 5 (FlowCover) - 10 row cuts average 92.4 elements, 0 column cuts (0 active)  in 0.006 seconds - new frequency is 1\nCbc0014I Cut generator 6 (TwoMirCuts) - 0 row cuts average 0.0 elements, 0 column cuts (0 active)  in 0.001 seconds - new frequency is -100\nCbc0014I Cut generator 7 (ZeroHalf) - 0 row cuts average 0.0 elements, 0 column cuts (0 active)  in 0.103 seconds - new frequency is -100\nCbc0010I After 0 nodes, 1 on tree, -1.1947726e+08 best solution, best possible -1.1950325e+08 (8.13 seconds)\nCbc0038I Full problem 2 rows 2109 columns, reduced to 2 rows 10 columns\nCbc0038I Full problem 2 rows 2109 columns, reduced to 2 rows 10 columns\nCbc0010I After 100 nodes, 55 on tree, -1.1947726e+08 best solution, best possible -1.1950325e+08 (9.52 seconds)\nCbc0038I Full problem 2 rows 2109 columns, reduced to 2 rows 6 columns\nCbc0010I After 200 nodes, 102 on tree, -1.1947726e+08 best solution, best possible -1.1950325e+08 (9.70 seconds)\nCbc0038I Full problem 2 rows 2109 columns, reduced to 2 rows 6 columns\nCbc0010I After 300 nodes, 150 on tree, -1.1947726e+08 best solution, best possible -1.1950325e+08 (9.84 seconds)\nCbc0038I Full problem 2 rows 2109 columns, reduced to 2 rows 6 columns\nCbc0010I After 400 nodes, 199 on tree, -1.1947726e+08 best solution, best possible -1.1950325e+08 (9.98 seconds)\nCbc0038I Full problem 2 rows 2109 columns, reduced to 2 rows 7 columns\nCbc0010I After 500 nodes, 248 on tree, -1.1947726e+08 best solution, best possible -1.1950325e+08 (10.12 seconds)\nCbc0038I Full problem 2 rows 2109 columns, reduced to 2 rows 8 columns\nCbc0010I After 600 nodes, 296 on tree, -1.1947726e+08 best solution, best possible -1.1950325e+08 (10.25 seconds)\nCbc0010I After 700 nodes, 346 on tree, -1.1947726e+08 best solution, best possible -1.1950325e+08 (10.36 seconds)\nCbc0010I After 800 nodes, 396 on tree, -1.1947726e+08 best solution, best possible -1.1950325e+08 (10.48 seconds)\nCbc0010I After 900 nodes, 442 on tree, -1.1947726e+08 best solution, best possible -1.1950325e+08 (10.58 seconds)\nCbc0010I After 1000 nodes, 491 on tree, -1.1947726e+08 best solution, best possible -1.1950325e+08 (10.68 seconds)\nCbc0010I After 1100 nodes, 590 on tree, -1.1947726e+08 best solution, best possible -1.1950325e+08 (10.76 seconds)\nCbc0012I Integer solution of -1.1950175e+08 found by rounding after 2525 iterations and 1168 nodes (10.82 seconds)\nCbc0012I Integer solution of -1.1950247e+08 found by DiveCoefficient after 2578 iterations and 1184 nodes (10.87 seconds)\nCbc0010I After 1200 nodes, 8 on tree, -1.1950247e+08 best solution, best possible -1.1950325e+08 (10.88 seconds)\nCbc0001I Search completed - best objective -119502473.087746, took 2700 iterations and 1229 nodes (10.91 seconds)\nCbc0032I Strong branching done 1234 times (2621 iterations), fathomed 7 nodes and fixed 23 variables\nCbc0035I Maximum depth 287, 267316 variables fixed on reduced cost\nCbc0038I Probing was tried 10 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.009 seconds)\nCbc0038I Gomory was tried 10 times and created 1 cuts of which 0 were active after adding rounds of cuts (0.004 seconds)\nCbc0038I Knapsack was tried 10 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.001 seconds)\nCbc0038I Clique was tried 10 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nCbc0038I MixedIntegerRounding2 was tried 256 times and created 3 cuts of which 0 were active after adding rounds of cuts (0.070 seconds)\nCbc0038I FlowCover was tried 256 times and created 135 cuts of which 0 were active after adding rounds of cuts (0.055 seconds)\nCbc0038I TwoMirCuts was tried 10 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.001 seconds)\nCbc0038I ZeroHalf was tried 10 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.103 seconds)\nCbc0012I Integer solution of -1.1950247e+08 found by Reduced search after 2773 iterations and 1279 nodes (10.93 seconds)\nCbc0001I Search completed - best objective -119502473.087746, took 2773 iterations and 1279 nodes (10.93 seconds)\nCbc0032I Strong branching done 170 times (233 iterations), fathomed 0 nodes and fixed 0 variables\nCbc0035I Maximum depth 24, 61999 variables fixed on reduced cost\nCuts at root node changed objective from -1.19504e+08 to -1.19504e+08\nProbing was tried 1 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.008 seconds)\nGomory was tried 1 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.001 seconds)\nKnapsack was tried 1 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.001 seconds)\nClique was tried 1 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nMixedIntegerRounding2 was tried 1 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.003 seconds)\nFlowCover was tried 1 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.001 seconds)\nTwoMirCuts was tried 1 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.001 seconds)\nZeroHalf was tried 1 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.001 seconds)\n\nResult - Optimal solution found\n\nObjective value:                119502473.08774604\nEnumerated nodes:               1279\nTotal iterations:               2773\nTime (CPU seconds):             10.28\nTime (Wallclock seconds):       10.97\n\nOption for printingOptions changed from normal to all\nTotal time (CPU seconds):       10.36   (Wallclock seconds):       11.07\n\nSolver status: Optimal\nStep 7 complete ‚Äî Model solved.\n\n\n\n\nExtracting and Interpreting the Selected Redevelopment Sites\nOnce the solver finishes, each decision variable x i ‚Äã\nhas a value in { 0 , 1 } . Interpretation:\nx(i) = 1: parcel (i) is selected in the optimal portfolio. x(i) = 0: parcel (i) is not selected.\nA selected_parcels DataFrame is constructed containing:\nParcel identifiers (PARCEL_ID)\nPhysical characteristics (lot size, assumed buildable GFA)\nFinancial metrics (revenue, cost, net uplift)\nThis serves as the core output of the optimization approach and can be visualized and tabulated.\n\n\n# STEP 8 ‚Äî Extract Selected Parcels\n\ncandidates[\"selected\"] = [pulp.value(x[i]) for i in candidates.index]\n\nselected_parcels = candidates[candidates[\"selected\"] &gt; 0.5].copy()\n\nprint(f\"Number of selected parcels: {len(selected_parcels)}\")\nselected_parcels[[\n    \"PARCEL_ID\", \"lot_sqft\", \"buildable_gfa\",\n    \"revenue\", \"cost\", \"net_uplift\"\n]].head()\n\nNumber of selected parcels: 100\n\n\n\n\n\n\n\n\n\nPARCEL_ID\nlot_sqft\nbuildable_gfa\nrevenue\ncost\nnet_uplift\n\n\n\n\n363\n1001684745\n5633.257617\n5633.257617\n1.971640e+06\n1.408314e+06\n562325.761691\n\n\n829\n1001623058\n383.996984\n383.996984\n1.343989e+05\n9.599925e+04\n30799.698380\n\n\n974\n1001167215\n1180.751146\n1180.751146\n4.132629e+05\n2.951878e+05\n113475.114557\n\n\n1405\n1001674492\n2285.637429\n2285.637429\n7.999731e+05\n5.714094e+05\n222263.742930\n\n\n1476\n1001674555\n995.842675\n995.842675\n3.485449e+05\n2.489607e+05\n94084.267492\n\n\n\n\n\n\n\n\n\nResults\nResult - Optimal solution found Objective value: 119502473.08774604 Enumerated nodes: 1279 Total iterations: 2773\nThis means:\n-Constraints were satisfied\n-Budget wasn‚Äôt exceeded\n-The solver found the best possible combination of parcels\n-The solution is mathematically valid and complete\n100 Parcels were selected\nThis is exactly what should happen from a sample of 5000 given the prioritizations:\nBudget = ~$300M\nMax sites = 500\nOnly positive uplift parcels are considered\nMany parcels have very low GFA\nFAR assumption = 1.0\nCosts & revenues produce realistic uplift estimates\n5,000 binary variables is a big model, and it still solved ver efficiently.\n\n\nTable\nWe can clearly see in this table that the mathematical model has done great work doing financial analysis per parcel and this data will be used moving foward to the final step of scoring each parcel.\n\n# Professional formatted table using pandas Styler\n\nstyled_table = (\n    selected_parcels\n    .assign(\n        buildable_gfa=lambda d: d[\"buildable_gfa\"].round(0).astype(int).map(\"{:,}\".format),\n        revenue=lambda d: d[\"revenue\"].map(\"${:,.0f}\".format),\n        cost=lambda d: d[\"cost\"].map(\"${:,.0f}\".format),\n        net_uplift=lambda d: d[\"net_uplift\"].map(\"${:,.0f}\".format)\n    )[\n        [\"PARCEL_ID\", \"buildable_gfa\", \"revenue\", \"cost\", \"net_uplift\"]\n    ]\n    .sort_values(\"net_uplift\", ascending=False)\n    .style.set_properties(**{\n        \"text-align\": \"center\",\n        \"font-size\": \"14px\"\n    })\n    .set_table_styles([\n        {\"selector\": \"thead th\", \"props\": [\n            (\"background-color\", \"#0F172A\"),\n            (\"color\", \"white\"),\n            (\"font-weight\", \"bold\"),\n            (\"padding\", \"10px\"),\n            (\"font-size\", \"15px\")\n        ]},\n        {\"selector\": \"tbody td\", \"props\": [\n            (\"padding\", \"8px\"),\n        ]}\n    ])\n)\n\nstyled_table\n\n\n\n\n\n\n¬†\nPARCEL_ID\nbuildable_gfa\nrevenue\ncost\nnet_uplift\n\n\n\n\n15748\n1001148842\n1,040\n$364,011\n$260,008\n$96,303\n\n\n10543\n1001075514\n1,022\n$357,590\n$255,422\n$95,569\n\n\n1476\n1001674555\n996\n$348,545\n$248,961\n$94,084\n\n\n19881\n1001127555\n957\n$334,938\n$239,242\n$92,397\n\n\n2579\n1001484533\n8,253\n$2,888,428\n$2,063,163\n$825,265\n\n\n2755\n1001401950\n152\n$53,283\n$38,060\n$8,524\n\n\n11652\n1001128024\n796\n$278,557\n$198,970\n$74,788\n\n\n5471\n1001075333\n733\n$256,579\n$183,271\n$70,008\n\n\n5054\n1001674487\n749\n$261,992\n$187,137\n$68,655\n\n\n16465\n1001445325\n745\n$260,754\n$186,253\n$68,301\n\n\n14951\n1001212272\n740\n$259,037\n$185,026\n$66,711\n\n\n19923\n1001113291\n665,927\n$233,074,565\n$166,481,832\n$66,592,733\n\n\n8364\n1001535110\n690\n$241,588\n$172,563\n$61,525\n\n\n1647\n1001248623\n688\n$240,742\n$171,959\n$61,083\n\n\n3067\n1001168316\n682\n$238,852\n$170,609\n$60,543\n\n\n8908\n1001502359\n680\n$238,018\n$170,013\n$60,405\n\n\n14479\n1001684154\n61,421\n$21,497,277\n$15,355,198\n$6,142,079\n\n\n3990\n1001348669\n669\n$234,033\n$167,166\n$58,966\n\n\n15959\n1001383422\n649\n$227,270\n$162,336\n$58,234\n\n\n363\n1001684745\n5,633\n$1,971,640\n$1,408,314\n$562,326\n\n\n4052\n1001286124\n619\n$216,521\n$154,658\n$55,163\n\n\n9225\n1001163664\n627\n$219,562\n$156,830\n$55,132\n\n\n2176\n1001228409\n5,277\n$1,846,891\n$1,319,208\n$527,683\n\n\n10230\n1001582492\n588\n$205,637\n$146,884\n$52,254\n\n\n1574\n1001675580\n5,187\n$1,815,529\n$1,296,806\n$515,523\n\n\n7621\n1001285140\n580\n$202,860\n$144,900\n$51,060\n\n\n6262\n1001302094\n561\n$196,393\n$140,281\n$48,612\n\n\n7231\n1001375630\n503\n$176,062\n$125,758\n$47,703\n\n\n13117\n1001531261\n546\n$190,927\n$136,376\n$47,651\n\n\n12735\n1001285128\n522\n$182,576\n$130,412\n$46,365\n\n\n19167\n1001163510\n519\n$181,743\n$129,816\n$46,226\n\n\n10590\n1001285136\n516\n$180,745\n$129,104\n$45,842\n\n\n5142\n1001302107\n530\n$185,509\n$132,507\n$45,503\n\n\n3733\n1001383416\n497\n$174,004\n$124,289\n$43,315\n\n\n19973\n1001166637\n497\n$174,043\n$124,317\n$43,227\n\n\n4031\n1001235402\n484\n$169,307\n$120,934\n$42,574\n\n\n9774\n1001094157\n489\n$171,025\n$122,161\n$42,264\n\n\n15220\n1001166635\n486\n$169,967\n$121,405\n$42,062\n\n\n1503\n1001383428\n484\n$169,481\n$121,058\n$42,023\n\n\n11731\n1001510501\n4,183\n$1,464,088\n$1,045,777\n$411,211\n\n\n17551\n1001269332\n459\n$160,574\n$114,695\n$40,578\n\n\n14276\n1001681864\n45,741\n$16,009,208\n$11,435,148\n$4,569,059\n\n\n15125\n1001683800\n40,340\n$14,118,888\n$10,084,920\n$4,033,968\n\n\n11549\n1001588395\n3,933\n$1,376,389\n$983,135\n$393,254\n\n\n5545\n1001326376\n466\n$163,204\n$116,574\n$39,430\n\n\n14397\n1001535154\n444\n$155,543\n$111,102\n$39,141\n\n\n15815\n1001383446\n453\n$158,402\n$113,144\n$38,058\n\n\n10981\n1001402701\n461\n$161,277\n$115,198\n$37,979\n\n\n19157\n1001535156\n431\n$150,767\n$107,691\n$37,776\n\n\n4151\n1001326367\n441\n$154,359\n$110,256\n$37,603\n\n\n9825\n1001326358\n436\n$152,512\n$108,937\n$36,375\n\n\n18018\n1001375212\n3,496\n$1,223,466\n$873,904\n$349,562\n\n\n19722\n1001303381\n3,514\n$1,229,896\n$878,497\n$344,199\n\n\n7368\n1001163684\n391\n$136,713\n$97,652\n$33,961\n\n\n11846\n1001623086\n388\n$135,815\n$97,011\n$31,904\n\n\n9754\n1001259368\n380\n$132,865\n$94,904\n$31,862\n\n\n18625\n1001623082\n381\n$133,472\n$95,337\n$31,235\n\n\n18180\n1001334208\n3,101\n$1,085,313\n$775,224\n$303,589\n\n\n9183\n1001334216\n3,101\n$1,085,313\n$775,224\n$303,189\n\n\n1781\n1001623063\n384\n$134,422\n$96,016\n$30,806\n\n\n829\n1001623058\n384\n$134,399\n$95,999\n$30,800\n\n\n19446\n1001235418\n373\n$130,615\n$93,296\n$29,618\n\n\n15428\n1001348692\n363\n$126,884\n$90,631\n$28,753\n\n\n14190\n1001442445\n336\n$117,470\n$83,907\n$28,563\n\n\n8092\n1001264272\n363\n$127,009\n$90,720\n$28,488\n\n\n3838\n1001487029\n355\n$124,123\n$88,659\n$28,064\n\n\n16963\n1001167281\n338\n$118,197\n$84,426\n$27,470\n\n\n5022\n1001685232\n2,689\n$941,198\n$672,285\n$268,914\n\n\n8030\n1001622866\n292\n$102,355\n$73,111\n$25,844\n\n\n17453\n1001262901\n2,523\n$883,024\n$630,731\n$244,893\n\n\n1405\n1001674492\n2,286\n$799,973\n$571,409\n$222,264\n\n\n9576\n1001674490\n2,286\n$799,973\n$571,409\n$221,264\n\n\n7166\n1001342304\n264\n$92,401\n$66,000\n$20,600\n\n\n11422\n1001430746\n28,762\n$10,066,837\n$7,190,598\n$2,876,239\n\n\n6408\n1001178940\n23,967\n$8,388,586\n$5,991,847\n$2,396,739\n\n\n18578\n1001051382\n1,990\n$696,612\n$497,580\n$192,932\n\n\n1855\n1001527910\n1,939\n$678,796\n$484,854\n$188,242\n\n\n18025\n1001683522\n175\n$61,226\n$43,733\n$17,493\n\n\n16867\n1001151750\n1,667\n$583,437\n$416,741\n$161,696\n\n\n14078\n1001554179\n1,630\n$570,548\n$407,535\n$158,014\n\n\n8011\n1001554186\n1,630\n$570,548\n$407,535\n$158,014\n\n\n18460\n1001541701\n1,599\n$559,623\n$399,730\n$153,392\n\n\n18699\n1001561055\n186\n$65,150\n$46,536\n$15,014\n\n\n8227\n1001146160\n1,565\n$547,764\n$391,260\n$149,904\n\n\n18641\n1001608307\n180\n$63,154\n$45,110\n$14,044\n\n\n17352\n1001561052\n176\n$61,507\n$43,934\n$13,973\n\n\n19704\n1001480220\n132,479\n$46,367,530\n$33,119,664\n$13,247,866\n\n\n18121\n1001428196\n1,288\n$450,915\n$322,082\n$124,933\n\n\n14559\n1001537728\n1,295\n$453,252\n$323,751\n$122,601\n\n\n11167\n1001051454\n1,241\n$434,338\n$310,242\n$121,397\n\n\n19568\n1001627457\n153\n$53,642\n$38,316\n$12,226\n\n\n974\n1001167215\n1,181\n$413,263\n$295,188\n$113,475\n\n\n19636\n1001436294\n177\n$61,862\n$44,187\n$11,675\n\n\n2709\n1001064573\n18,030\n$6,310,386\n$4,507,418\n$1,798,567\n\n\n15826\n1001252983\n16,168\n$5,658,792\n$4,041,994\n$1,616,798\n\n\n2133\n1001248925\n15,882\n$5,558,737\n$3,970,526\n$1,588,211\n\n\n15357\n1001401262\n15,200\n$5,320,059\n$3,800,042\n$1,520,017\n\n\n8008\n1001078334\n12,258\n$4,290,365\n$3,064,546\n$1,225,818\n\n\n18329\n1001687615\n10,445\n$3,655,811\n$2,611,294\n$1,044,518\n\n\n2228\n1001580049\n10,230\n$3,580,579\n$2,557,556\n$1,019,722\n\n\n\n\n\n\n\nDash Board of the Parcels Selected for Redevelopment\nNote\nThe model only computes 20000 parcels due to the size of the data sampling up will result in more parcel selections.\n\nselected_polygons = selected_parcels.copy()\n\n# Convert projection from EPSG:2272 (feet) ‚Üí WGS84 (lat/lon)\nselected_polygons_wgs = selected_polygons.to_crs(4326)\n\n\n# Ensure net_uplift is numeric\nselected_polygons_wgs[\"net_uplift\"] = pd.to_numeric(\n    selected_polygons_wgs[\"net_uplift\"], errors=\"coerce\"\n)\n\nselected_polygons_wgs.hvplot.polygons(\n    geo=True,\n    tiles=\"CartoDark\",\n    color=\"net_uplift\",\n    cmap=\"YlGn\",\n    line_color=\"white\",\n    line_width=1.5,\n    alpha=0.8,\n    hover_cols=[\n        \"PARCEL_ID\",\n        \"lot_sqft\",\n        \"buildable_gfa\",\n        \"revenue\",\n        \"cost\",\n        \"net_uplift\"\n    ],\n    title=\"Optimized Redevelopment Parcels\",\n    width=900,\n    height=650\n)"
  },
  {
    "objectID": "final_project.html#non-financial-metrics-computations---qualitative-parcel-variables",
    "href": "final_project.html#non-financial-metrics-computations---qualitative-parcel-variables",
    "title": "Development Opportunity Optimizer",
    "section": "4. Non-Financial Metrics Computations - Qualitative Parcel Variables",
    "text": "4. Non-Financial Metrics Computations - Qualitative Parcel Variables\nIn this stage of the project, we construct a multi-dimensional redevelopment opportunity index for Philadelphia parcels. While the PuLP optimization produces the mathematically optimal redevelopment portfolio under financial constraints, we also require a qualitative and spatially sensitive scoring framework that evaluates parcels across several redevelopment-relevant dimensions. The goal is to create a Redevelopment Opportunity Score‚Äîa normalized, weighted composite of metrics capturing:\n\nPhysical Underutilization Assesses whether land is being used below its potential. Parcels with small buildings relative to lot area often represent redevelopment opportunities.\nMarket Gap Evaluates discrepancies between market-implied value and tax-assessed value. Undervalued parcels may indicate strong repositioning potential or overlooked market opportunity.\nStructural Obsolescence (Old Structure Flag) Marks parcels with older buildings (pre-1950), which are more likely to be physically obsolete, inefficient, or candidates for redevelopment.\nZoning Capacity Proxy Approximates allowed density using a simplified FAR assumption. Parcels with high buildable capacity relative to existing structures often present upzoning or intensification opportunity.\nAccessibility Potential (Lightweight Score) Captures demand-side viability via proximity to major intersections within the city‚Äôs street network. Closer proximity generally correlates with increased mobility, visibility, and development attractiveness.\nFinancial Potential (Net Uplift) Incorporates your estimated uplift from redevelopment (revenue ‚àí cost ‚àí assessed value). This ensures the scoring system includes an explicit economic incentive component.\nOpportunity Score (Weighted Composite) The final index, after normalizing metrics 0‚Äì1 using MinMaxScaler and weighting them according to redevelopment relevance. This creates a continuous measure that can be mapped, filtered, ranked, and compared with PuLP outputs in the final dashboard.\n\n\nCreate Working Data Set\nAn isolated dataset is produced specifically for scoring to ensure that no prior notebook state or variable reuse affects results. This dataset includes all core parcel attributes necessary for computing qualitative, spatial, and financial indicators.\n\n# STEP 1 ‚Äî Create Data Set For Scoring\n\nqualitative_df = parcel_map_base.copy()\n\nqualitative_df[\"BUILDING_SQFT\"] = pd.to_numeric(qualitative_df[\"BUILDING_SQFT\"], errors=\"coerce\")\nqualitative_df[\"ASSESSED_VALUE\"] = pd.to_numeric(qualitative_df[\"ASSESSED_VALUE\"], errors=\"coerce\")\nqualitative_df[\"YEAR_BUILT\"] = pd.to_numeric(qualitative_df[\"YEAR_BUILT\"], errors=\"coerce\")\nqualitative_df[\"lot_sqft\"] = qualitative_df.geometry.area\n\n# Recompute Financial Variables Needed for Scoring\n\n# FAR assumption\nfar = 2.0\n\n# Estimated buildable gross floor area\nqualitative_df[\"buildable_gfa\"] = qualitative_df[\"lot_sqft\"] * far\n\n# Market price per buildable sqft\nmarket_price_per_sqft = 350\n\n# Estimated revenue\nqualitative_df[\"revenue\"] = qualitative_df[\"buildable_gfa\"] * market_price_per_sqft\n\n# Construction cost assumption \ncost_per_sqft = 250\n\n# Estimated cost\nqualitative_df[\"cost\"] = qualitative_df[\"buildable_gfa\"] * cost_per_sqft\n\n# Net uplift definition\nqualitative_df[\"net_uplift\"] = (\n    qualitative_df[\"revenue\"] -\n    qualitative_df[\"cost\"] -\n    qualitative_df[\"ASSESSED_VALUE\"].fillna(0)\n)\n\nprint(\"Pre-step complete ‚Äî Financial variables added to qualitative_df.\")\n\n\nprint(\"Step 1 complete ‚Äî Working dataset 'qualitative_df' ready.\")\n\nPre-step complete ‚Äî Financial variables added to qualitative_df.\nStep 1 complete ‚Äî Working dataset 'qualitative_df' ready.\n\n\n\n\nComputing Underutilization Ratio\nThis metric evaluates how intensively land is used relative to its physical footprint. Parcels with a low building-to-land ratio are often underdeveloped, making them attractive candidates for redevelopment or intensification.\n\n# STEP 2 ‚Äî Computing Underutilization Ratio\n\nqualitative_df[\"underutilization\"] = qualitative_df[\"BUILDING_SQFT\"] / qualitative_df[\"lot_sqft\"]\nqualitative_df[\"underutilization\"] = qualitative_df[\"underutilization\"].fillna(0)\n\nprint(\"Step 2 complete ‚Äî Underutilization ratio computed.\")\n\nStep 2 complete ‚Äî Underutilization ratio computed.\n\n\n\n\nComputing Market Gap\nThe market gap metric identifies parcels where market-implied value (using your revenue proxy) exceeds assessed value. A high ratio suggests the property may be undervalued or inefficiently used, signalling market-driven redevelopment potential.\n\n# STEP 3 ‚Äî Compute Market Gap\n\nqualitative_df[\"market_gap\"] = qualitative_df[\"revenue\"] / qualitative_df[\"ASSESSED_VALUE\"].replace(0, np.nan)\nqualitative_df[\"market_gap\"] = qualitative_df[\"market_gap\"].fillna(0)\n\nprint(\"Step 3 complete ‚Äî Market gap computed.\")\n\nStep 3 complete ‚Äî Market gap computed.\n\n\n\n\nOld Structure Variable\nOlder buildings are more likely to be obsolete, structurally inefficient, or out of sync with current zoning and market expectations. Parcels with pre-1950 structures often represent high redevelopment potential.\n\n# STEP 4 ‚Äî Old Structure Flag\n\nqualitative_df[\"old_structure\"] = (qualitative_df[\"YEAR_BUILT\"] &lt; 1950).astype(int)\n\nprint(\"Step 4 complete ‚Äî Old structure flag added.\")\n\nStep 4 complete ‚Äî Old structure flag added.\n\n\n\n\nZoning Capacity Proxy\nSince citywide zoning joins are computationally intensive, we apply a generalized FAR assumption to approximate theoretical development capacity. Parcels with high zoning capacity relative to their existing improvements often hold latent intensification potential.\n\n# STEP 5 ‚Äî Zoning Capacity Proxy\n\nmax_far_proxy = 3.0\nqualitative_df[\"zoning_capacity\"] = qualitative_df[\"lot_sqft\"] * max_far_proxy\n\nprint(\"Step 5 complete ‚Äî Zoning capacity proxy computed.\")\n\nStep 5 complete ‚Äî Zoning capacity proxy computed.\n\n\n\n\nAccessibility Score Using osmnx\nAccessibility is a fundamental component of redevelopment potential. Instead of performing computationally expensive network routing, we estimate accessibility via the inverse distance from each parcel centroid to the nearest major street-network node. This provides a meaningful, fast, and scalable measure of urban connectivity.\n\n# STEP 6 ‚Äî FAST ACCESSIBILITY SCORE USING MAJOR INTERSECTIONS\n# -------------------------------------------------------------------------\n# This optimized method replaces the slow OSMnx nearest-node lookup.\n#\n# Instead of snapping each parcel to ALL nodes in the street graph, we:\n#   1. Download the drivable network for Philadelphia.\n#   2. Extract ONLY major intersections (nodes with degree ‚â• 3),\n#      which represent key points of connectivity.\n#   3. Build a KDTree for fast nearest-neighbor search.\n#   4. Compute Euclidean distance from each parcel centroid to the\n#      closest major intersection.\n#   5. Convert this distance to an accessibility score via 1/distance.\n#\n# This produces a meaningful access metric and reduces runtime by ~90%.\n# -------------------------------------------------------------------------\n\n\n\n# Compute centroids \nqualitative_df[\"centroid\"] = qualitative_df.geometry.centroid\n\n# Convert centroids to WGS84 for OSMnx\nqualitative_df_wgs = qualitative_df.set_geometry(\"centroid\").to_crs(4326)\n\n# Download drivable OSM network for Philadelphia\nG = ox.graph_from_place(\"Philadelphia, Pennsylvania, USA\", network_type=\"drive\")\n\n# Extract nodes as a GeoDataFrame\nnodes = ox.graph_to_gdfs(G, edges=False)\n\n# Identify \"major intersections\" = nodes with degree &gt;= 3\ndegree_dict = dict(G.degree())\nmajor_nodes = nodes[nodes.index.map(lambda n: degree_dict.get(n, 0) &gt;= 3)]\n\n# Build KDTree for nearest neighbor search\nmajor_points = np.vstack([major_nodes[\"x\"].values, major_nodes[\"y\"].values]).T\ntree = cKDTree(major_points)\n\n# Parcel centroid coordinates\nparcel_points = np.vstack([\n    qualitative_df_wgs.geometry.x.values,\n    qualitative_df_wgs.geometry.y.values\n]).T\n\n# Compute nearest major intersection distance\ndistances, _ = tree.query(parcel_points, k=1)\n\n# Accessibility = higher when closer to intersections\nqualitative_df[\"accessibility_score\"] = 1 / (distances + 1e-6)\n\nprint(\"Step 6 complete ‚Äî Major-intersection accessibility score computed.\")\n\nStep 6 complete ‚Äî Fast major-intersection accessibility score computed."
  },
  {
    "objectID": "final_project.html#normalize-metrics-using-minmaxscaler-and-calculate-weighted-opportunity-score",
    "href": "final_project.html#normalize-metrics-using-minmaxscaler-and-calculate-weighted-opportunity-score",
    "title": "Development Opportunity Optimizer",
    "section": "4. Normalize Metrics Using MinMaxScaler and Calculate Weighted Opportunity Score",
    "text": "4. Normalize Metrics Using MinMaxScaler and Calculate Weighted Opportunity Score\nEach qualitative indicator is measured in different, units are (sqft, dollars, ratios, binary, etc.). To make them comparable and suitable for weighted scoring, they are normalized to the same 0‚Äì1 scale using MinMaxScaler. This prevents any single metric from overpowering the composite Opportunity Score.\nRedevelopment indicators exist on different scales and magnitudes. Normalization transforms them into a uniform 0‚Äì1 range, ensuring comparability and enabling weighted scoring without bias toward metrics with larger numeric ranges\nThe Opportunity Score is a composite redevelopment metric constructed from weighted normalized indicators. Weights are assigned based on redevelopment relevance:\n\nUnderutilization (25%)\nMarket gap (20%)\nOld structure (10%)\nZoning capacity proxy (15%)\nAccessibility (10%)\nFinancial uplift (20%)\n\nThis produces a continuous index ranging from 0 to 1, allowing for ranking, mapping, and comparison with the optimization model. Higher values indicate stronger redevelopment potential under qualitative criteria.\nWe aggregate all normalized indicators into a composite Opportunity Score reflecting multiple redevelopment dimensions. This creates a single interpretable measure for ranking parcels, building dashboard filters, and comparing with PuLP optimization outcomes.\n\n# STEP 1 ‚Äî Normalize Metrics\n\n# Initialize scaler\nscaler = MinMaxScaler()\n\n# Select metrics to normalize\nmetrics_to_scale = qualitative_df[[\n    \"underutilization\",\n    \"market_gap\",\n    \"old_structure\",\n    \"zoning_capacity\",\n    \"accessibility_score\",\n    \"net_uplift\"\n]]\n\n# Fit-transform metrics to 0‚Äì1 range\nscaled = scaler.fit_transform(metrics_to_scale)\n\n# Store normalized metrics in a new Data Frame\nscaled_df = pd.DataFrame(\n    scaled,\n    columns=[col + \"_norm\" for col in metrics_to_scale.columns],\n    index=qualitative_df.index\n)\n\n# Add normalized metrics to original dataset\nqualitative_df = pd.concat([qualitative_df, scaled_df], axis=1)\n\nprint(\"Step 1 complete ‚Äî Metrics normalized.\")\n\nStep 7 complete ‚Äî Metrics normalized.\n\n\n\n\n# STEP 2 ‚Äî Compute Weighted Opportunity Score\n\nqualitative_df[\"opportunity_score\"] = (\n    0.25 * qualitative_df[\"underutilization_norm\"] +\n    0.20 * qualitative_df[\"market_gap_norm\"] +\n    0.10 * qualitative_df[\"old_structure_norm\"] +\n    0.15 * qualitative_df[\"zoning_capacity_norm\"] +\n    0.10 * qualitative_df[\"accessibility_score_norm\"] +\n    0.20 * qualitative_df[\"net_uplift_norm\"]\n)\n\nprint(\"Step 2 complete ‚Äî Opportunity Score computed.\")\n\nStep 2 complete ‚Äî Opportunity Score computed.\n\n\nThis Concludes all Data Analysis and Computations, the final piece of the tool is the visualization dashboard."
  },
  {
    "objectID": "final_project.html#analytics-business-intelligence-dashboard",
    "href": "final_project.html#analytics-business-intelligence-dashboard",
    "title": "Development Opportunity Optimizer",
    "section": "5. Analytics Business Intelligence Dashboard",
    "text": "5. Analytics Business Intelligence Dashboard\n\n\n# =========================================================\n# FINAL FAST DASHBOARD (CENTROIDS ONLY, WITH SAMPLING)\n# =========================================================\n\nimport geopandas as gpd\nimport numpy as np\nimport pandas as pd\nimport panel as pn\nimport holoviews as hv\nimport hvplot.pandas\nhv.extension(\"bokeh\")\n\n# ---------------------------------------------------------\n# 1. FAST CENTROID PREPARATION ‚Äî NO POLYGON REPROJECTION\n# ---------------------------------------------------------\n\nparcel_map_base[\"centroid\"] = parcel_map_base.geometry.centroid\nqualitative_df[\"centroid\"]  = qualitative_df.geometry.centroid\n\nparcel_pts = gpd.GeoDataFrame(\n    parcel_map_base.drop(columns=\"geometry\"),\n    geometry=parcel_map_base[\"centroid\"],\n    crs=\"EPSG:2272\"\n)\n\nqual_pts = gpd.GeoDataFrame(\n    qualitative_df.drop(columns=\"geometry\"),\n    geometry=qualitative_df[\"centroid\"],\n    crs=\"EPSG:2272\"\n)\n\nparcel_pts_3857 = parcel_pts.to_crs(epsg=3857)\nqual_pts_3857   = qual_pts.to_crs(epsg=3857)\n\nparcel_pts_3857[\"x\"] = parcel_pts_3857.geometry.x\nparcel_pts_3857[\"y\"] = parcel_pts_3857.geometry.y\n\nqual_pts_3857[\"x\"]   = qual_pts_3857.geometry.x\nqual_pts_3857[\"y\"]   = qual_pts_3857.geometry.y\n\nprint(\"Centroid prep complete ‚Äî ready for dashboard (with sampling).\")\n\n\n# ---------------------------------------------------------\n# 2. BASE TILE LAYER\n# ---------------------------------------------------------\n\ntiles = hv.element.tiles.CartoDark().opts(width=900, height=600)\n\n\n# ---------------------------------------------------------\n# 3. SAMPLING FUNCTION TO KEEP MAPS FAST\n# ---------------------------------------------------------\n\ndef sample_df(df, n=20000):\n    if len(df) &gt; n:\n        return df.sample(n, random_state=42)\n    return df\n\n\n# ---------------------------------------------------------\n# 4. OPPORTUNITY SCORE MAP (TAB 1)\n# ---------------------------------------------------------\n\ndef opportunity_map():\n    df = sample_df(qual_pts_3857, n=20000)\n\n    pts = df.hvplot.points(\n        x=\"x\", y=\"y\",\n        color=\"opportunity_score\",\n        cmap=\"Viridis\",\n        size=5, alpha=0.7,\n        hover_cols=[\"PARCEL_ID\", \"opportunity_score\"],\n        geo=False, width=900, height=600,\n        title=\"Redevelopment Opportunity Score\"\n    )\n\n    return tiles * pts\n\n\n# ---------------------------------------------------------\n# 5. EXPLORER MAP (TAB 2)\n# ---------------------------------------------------------\n\nattr_select = pn.widgets.Select(\n    name=\"Attribute\",\n    options=[\n        \"ASSESSED_VALUE\",\"SALE_PRICE\",\"VACANT_FLAG\",\n        \"PERMIT_COUNT\",\"lot_sqft\",\"building_sqft\",\"year_built\"\n    ],\n    value=\"ASSESSED_VALUE\"\n)\n\ndef explorer_map(attr):\n    df = sample_df(parcel_pts_3857, n=20000)\n\n    pts = df.hvplot.points(\n        x=\"x\", y=\"y\",\n        color=attr,\n        cmap=\"YlGn\",\n        size=5, alpha=0.7,\n        hover_cols=[\"PARCEL_ID\", attr],\n        geo=False, width=900, height=600,\n        title=f\"Parcels Colored by {attr} (20,000 sample)\"\n    )\n\n    return tiles * pts\n\nexplorer_panel = pn.bind(explorer_map, attr=attr_select)\n\n\n# ---------------------------------------------------------\n# 6. BUILD TABS\n# ---------------------------------------------------------\n\ntab1 = pn.Column(\n    \"Opportunity Score Map\",\n    opportunity_map()\n)\n\ntab2 = pn.Column(\n    \"Parcel Explorer\",\n    attr_select,\n    explorer_panel\n)\n\ndashboard = pn.Tabs(\n    (\"Opportunity Score\", tab1),\n    (\"Parcel Explorer\", tab2)\n)\n\ndashboard\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\nCentroid prep complete ‚Äî ready for dashboard (with sampling)."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "A Business Intelligence Real Estate Analytics Tool",
    "section": "",
    "text": "Welcome to my final project website.\nThis project includes:\n\nGeospatial preprocessing\n\nParcel-level redevelopment opportunity scoring\n\nPredictive modeling\n\nInteractive dashboards\n\nOptimization using PuLP\n\n\n\n\n\nOpen the Analysis Notebook"
  },
  {
    "objectID": "index.html#full-jupyter-notebook-test",
    "href": "index.html#full-jupyter-notebook-test",
    "title": "A Business Intelligence Real Estate Analytics Tool",
    "section": "",
    "text": "Open the Analysis Notebook"
  }
]